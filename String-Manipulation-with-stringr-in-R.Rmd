## String Manipulation {.unnumbered}

<h3 class="course__description-title">Charlotte Wickham</h3>
<p class="course__instructor-description display-none-mobile-course-page-experiment">
    Charlotte is an Senior Instructor in the Department of Statistics at Oregon State University and an avid R programmer with a passion for teaching. Her interests lie in spatiotemporal data, statistical graphics and computing, and environmental statistics.
  </p>

**Course Description**

<p class="course__description">Character strings can turn up in all stages of a data science project. You might have to clean messy string input before analysis, extract data that is embedded in text or automatically turn numeric results into a sentence to include in a report. Perhaps the strings themselves are the data of interest, and you need to detect and match patterns within them. This course will help you master these tasks by teaching you how to pull strings apart, put them back together and use stringr to detect, extract, match and split strings using regular expressions, a powerful way to express patterns.</p>

### String basics {.unnumbered}

<p class="chapter__description">
    You'll start with some basics: how to enter strings in R, how to control how numbers are transformed to strings, and finally how to combine strings together to produce output that combines text and nicely formatted numbers.
  </p>
  
#### Welcome! {.unnumbered}



##### Quotes {.unnumbered}


<div class>
<p>Let's get started by entering some strings in R.  In the video you saw that you use quotes to tell R to interpret something as a string.  Both double quotes (<code>"</code>) and single (<code>'</code>) quotes work, but there are some guidelines for which to use. </p>
<p>First, you should prefer double quotes (<code>"</code>) to single quotes (<code>'</code>).  That means, whenever you are defining a string your first intuition should be to use <code>"</code>.</p>
<p>Unfortunately if your string has <code>"</code> inside it, R will interpret the double quote as \"this is the end of the string\", not as \"this is the character <code>"</code>\".  This is one time you can forget the first guideline and use the single quote, <code>'</code>, to define the string.</p>
<p>Finally, there are cases where you need both <code>'</code> and <code>"</code> inside the string.  In this case, fall back to the first guideline and use <code>"</code> to define the string, but you'll have to escape any double quotes inside the string using a backslash (i.e. <code>\"</code>).</p>
<p>To practice, you are going to enter a few lines from Lewis Carroll's <em>Alice's Adventures in Wonderland</em>.  Alice has just arrived at the tea party…</p>
</div>
<div class="exercise--instructions__content">
<p>Following the guidelines for using quotes, define the three strings, <code>line1</code>, <code>line2</code> and <code>line3</code>:</p>
<ul>
<li><code>The table was a large one, but the three were all crowded together at one corner of it:</code>
</li>
<li><code>"No room! No room!" they cried out when they saw Alice coming.</code>
</li>
<li><code>"There's plenty of room!" said Alice indignantly, and she sat down in a large arm-chair at one end of the table.</code>
</li>
</ul>
</div>
```{r,warning=F,message=F}
# Define line1
line1 <- "The table was a large one, but the three were all crowded together at one corner of it:"

# Define line2
line2 <- '"No room! No room!" they cried out when they saw Alice coming.' 

# Define line3
line3 <- "\"There's plenty of room!\" said Alice indignantly, and she sat down in a large arm-chair at one end of the table."
```

<div class="dc-completed__message"><p class="">Fantastic! You can escape quotes inside strings using a backslash.
</p></div>

##### What you see isn't always what you have {.unnumbered}


<div class>
<p>Take a look at <code>line2</code>, the string you just defined, by printing it:</p>
<pre><code>line2
</code></pre>
<p>Even though you used single quotes so you didn't have to escape any double quotes, when R prints it, you'll see escaped double quotes (<code>\"</code>)!  R doesn't care how you defined the string, it only knows what the string represents, in this case, a string with double quotes inside.  </p>
<p>When you ask R for <code>line2</code> it is actually calling <code>print(line2)</code> and the <a href="https://www.rdocumentation.org/packages/base/topics/print"><code>print()</code></a> method for strings displays strings as you might enter them.  If you want to see the string it represents you'll need to use a different function: <a href="https://www.rdocumentation.org/packages/base/topics/writeLines"><code>writeLines()</code></a>.</p>
<p>You can pass <a href="https://www.rdocumentation.org/packages/base/topics/writeLines"><code>writeLines()</code></a> a vector of strings and it will print them to the screen, each on a new line.  This is a great way to check the string you entered really does represent the string you wanted.</p>
</div>
<div class="exercise--instructions__content">
<p>We've put your lines from  <em>Alice's Adventures in Wonderland</em> in a vector called <code>lines</code>.</p>

<li>Take a look at <code>lines</code> to see R's representation of the strings.</li>
```{r,warning=F,message=F}
# Putting lines in a vector
lines <- c(line1, line2, line3)

# Print lines
lines
```
<li>Pass <code>lines</code> to <a href="https://www.rdocumentation.org/packages/base/topics/writeLines"><code>writeLines()</code></a> to see the content of strings you've created.</li>
```{r,warning=F,message=F}
# Use writeLines() on lines
writeLines(lines)
```
<li>By default <code>writeLines()</code> separates the strings with a newline, which you can change using the <code>sep</code> argument.  Write <code>lines</code> to the screen again, but this time set the <code>sep</code> argument to a space, <code>" "</code>.</li>
```{r,warning=F,message=F}
# Write lines with a space separator
writeLines(lines, sep = " ")
```
<li>Finally, try using <code>writeLines()</code> on the string <code>"hello\\n\\U1F30D"</code>. <em>You'll learn about what's going on here in the next exercise.</em>
</li>
```{r,warning=F,message=F}
# Use writeLines() on the string "hello\n\U1F30D"
writeLines("hello\n\U1F30D")
```
</div>

<p class="">Perfect! The function <code>cat()</code> is very similar to <code>writeLines()</code>, but by default separates elements with a space, and will attempt to convert non-character objects to a string.  We won't use it in this course, but you might see it in other people's code.
</p>

##### Escape sequences {.unnumbered}


<div class>
<p>You might have been surprised at the output from the last part of the last 
exercise.  How did you get two lines from one string, and how did you get that
little globe?  The key is the <code>\\</code>.  </p>
<p>A sequence in a string that starts with a <code>\\</code> is called an <em>escape sequence</em> and 
allows us to include special characters in our strings.  You saw one escape 
sequence in the first exercise: <code>\\"</code> is used to denote a double quote.</p>
<p>In <code>"hello\\n\\U1F30D"</code> there are two escape sequences: <code>\\n</code> gives a newline, 
and <code>\\U</code> followed by up to 8 hex digits sequence denotes a particular Unicode
character. </p>
<p>Unicode is a standard for representing characters that might not be on your 
keyboard.  Each available character has a Unicode code point: a number that 
uniquely identifies it.  These code points are generally written in hex
notation, that is, using base 16 and the digits 0-9 and A-F.  You can find the
code point for a particular character by looking up a <a href="http://www.unicode.org/charts/">code
chart</a>.  If you only need four digits for the 
codepoint, an alternative escape sequence is <code>\\u</code>.  </p>
<p>When R comes across a <code>\\</code> it assumes you are starting an escape, so if you 
actually need a backslash in your string you'll need the sequence <code>\\</code>.</p>
</div>
<div class="exercise--instructions__content">
<li>
<p>Edit the string inside <a href="https://www.rdocumentation.org/packages/base/topics/writeLines"><code>writeLines()</code></a> so that it correctly displays 
(all on one line):</p>
<pre><code>To have a \ you need \\
</code></pre>
</li>
```{r,warning=F,message=F}
# Should display: To have a \ you need \\
writeLines("To have a \\ you need \\\\")
```
<li>
<p>Edit the string inside <code>writeLines()</code> so that it correctly displays (with the
line breaks in these positions)</p>
<pre><code>This is a really 
really really 
long string
</code></pre>
</li>
```{r,warning=F,message=F}
# Should display: 
# This is a really 
# really really 
# long string
writeLines("This is a really \nreally really \nlong string")
```
<li><p>Try <code>writeLines()</code> with the string containing Unicode characters:
<code>"\\u0928\\u092e\\u0938\\u094d\\u0924\\u0947 \\u0926\\u0941\\u0928\\u093f\\u092f\\u093e"</code>.  You just said "Hello World" in Hindi!</p></li>
```{r,warning=F,message=F}
# Use writeLines() with 
# "\u0928\u092e\u0938\u094d\u0924\u0947 \u0926\u0941\u0928\u093f\u092f\u093e"
writeLines("\u0928\u092e\u0938\u094d\u0924\u0947 \u0926\u0941\u0928\u093f\u092f\u093e")
```
</div>

<p class="">Nice job! You can read about a few other escape sequences in the help page <a href="https://www.rdocumentation.org/packages/base/topics/Quotes" target="_blank" rel="noopener noreferrer"><code>?Quotes</code></a>.
</p>

#### Turning numbers into strings {.unnumbered}



##### Using format() with numbers {.unnumbered}


<div class>
<p>The behavior of  <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a> can be pretty confusing, so you'll spend most of this exercise exploring how it works.</p>
<p>Recall from the video, the <code>scientific</code> argument to <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a> controls whether the numbers are displayed in fixed (<code>scientific = FALSE</code>) or scientific (<code>scientific = TRUE</code>) format.</p>
<p>When the representation is scientific, the <code>digits</code> argument is the number of digits before the exponent. 
When the representation is fixed, <code>digits</code> controls the significant digits used for the smallest (in magnitude) number. Each other number will be formatted to match the number of decimal places in the smallest number.  This means the number of decimal places you get in your output depends on <strong>all</strong> the values you are formatting!</p>
<p>For example, if the smallest number is 0.0011, and <code>digits = 1</code>, then 0.0011 requires 3 places after the decimal to represent it to 1 significant digit, 0.001.  Every other number will be formatted to 3 places after the decimal point.  </p>
<p>So, how many decimal places will you get if 1.0011 is the smallest number? You'll find out in this exercise.</p>
</div>
<div class="exercise--instructions__content">
<li>Format <code>c(0.0011, 0.011, 1)</code> with <code>digits = 1</code>.  <em>This is like the example described above.</em>
</li>
```{r,warning=F,message=F}
# Some vectors of numbers
percent_change <- c(4, -1.91, 3.00, -5.002)
income <- c(72.19, 1030.18, 10291.93, 1189192.18)
p_values <- c(0.12, 0.98, 0.0000191, 0.00000000002)
```
```{r,warning=F,message=F}
# Format c(0.0011, 0.011, 1) with digits = 1
format(c(0.0011, 0.011, 1), digits = 1)
```
<li>Now, format <code>c(1.0011, 2.011, 1)</code> with <code>digits = 1</code>. <em>Try to predict what you might get before you try it.</em>
</li>
```{r,warning=F,message=F}
# Format c(1.0011, 2.011, 1) with digits = 1
format(c(1.0011, 2.011, 1), digits = 1)
```
<li>Format <code>percent_change</code> by choosing the <code>digits</code> argument so that the values are presented with one place after the decimal point.</li>
```{r,warning=F,message=F}
# Format percent_change to one place after the decimal point
format(percent_change, digits = 2)
```
<li>Format <code>income</code> by choosing the <code>digits</code> argument so that the values are presented as whole numbers (i.e. no places after the decimal point).</li>
```{r,warning=F,message=F}
# Format income to whole numbers
format(income, digits = 2)
```
<li>Format <code>p_values</code> using a fixed representation.</li>
```{r,warning=F,message=F}
# Format p_values in fixed format
format(p_values, scientific = FALSE)
```
</div>

<p class="">Don't worry if you find this behavior a bit confusing. So do we!  Often getting numbers to look like you want them to takes some trial and error with the arguments to <code>format()</code>.
</p>

##### Controlling other aspects of the string {.unnumbered}


<div class>
<p>Not only does <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a> control the way the number is represented, it also controls some of the properties of the resulting string that affect its display.</p>
<p>For example, by default <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a> will pad the start of the strings with spaces so that the decimal points line up, which is really useful if you are presenting the numbers in a vertical column.  However, if you are putting the number in the middle of a sentence, you might not want these extra spaces. You can set <code>trim = TRUE</code> to remove them.</p>
<p>When numbers are long it can be helpful to "prettify" them, for example instead of <code>1000000000</code> display <code>1,000,000,000</code>.  In this case a <code>,</code> is added every <code>3</code> digits.  This can be controlled by the <code>big.interval</code> and <code>big.mark</code> arguments, e.g. <code>format(1000000000, big.mark = ",", big.interval = 3, scientific = FALSE)</code>.  These arguments are actually passed on to <a href="https://www.rdocumentation.org/packages/base/topics/prettyNum"><code>prettyNum()</code></a>  so head there for any further details.</p>
</div>
<div class="exercise--instructions__content">
<p>We've assigned your formatted <code>income</code> from the previous exercise to <code>formatted_income</code>.</p>

<li>Print <code>formatted_income</code> <em>Notice the spaces at the start of the strings.</em>
</li>
```{r,warning=F,message=F}
formatted_income <- format(income, digits = 2)

# Print formatted_income
formatted_income
```
<li>Call <code>writeLines()</code> on the formatted <code>income</code>.  <em>Notice how the numbers line up on the decimal point.</em>
</li>
```{r,warning=F,message=F}
# Call writeLines() on the formatted income
writeLines(formatted_income)
```
<li>Define <code>trimmed_income</code> by using <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a> on <code>income</code> with <code>digits = 2</code> and <code>trim = TRUE</code>.</li>
```{r,warning=F,message=F}
# Define trimmed_income
trimmed_income <- format(income, digits = 2, trim = TRUE)
```
<li>Call <code>writeLines()</code> on <code>trimmed_income</code>.  <em>Notice how this removes the spaces at the start of the strings and the values line up on left.</em>
</li>
```{r,warning=F,message=F}
# Call writeLines() on the trimmed_income
writeLines(trimmed_income)
```
<li>Define <code>pretty_income</code> by using <code>format()</code> on <code>income</code> with <code>digits = 2</code> and <code>big.mark = ","</code>.</li>
```{r,warning=F,message=F}
# Define pretty_income
pretty_income <- format(income, digits = 2, big.mark = ",")
```
<li>Call <code>writeLines()</code> on <code>pretty_income</code>.</li>
```{r,warning=F,message=F}
# Call writeLines() on the pretty_income
writeLines(pretty_income)
```
</div>

<p class="">Phenomenal work! <code>format()</code> is powerful but tricky to use. An alternative is provided by <code>formatC()</code>.
</p>

##### formatC() {.unnumbered}


<div class>
<p>The function <a href="https://www.rdocumentation.org/packages/base/topics/formatC"><code>formatC()</code></a> provides an alternative way to format numbers based on C style syntax.  </p>
<p>Rather than a <code>scientific</code> argument, <a href="https://www.rdocumentation.org/packages/base/topics/formatC"><code>formatC()</code></a> has a <code>format</code> argument that takes a code representing the required format. The most useful are:</p>

<li>
<code>"f"</code> for fixed, </li>
<li>
<code>"e"</code> for scientific, and </li>
<li>
<code>"g"</code> for fixed unless scientific saves space</li>
</ul>
<p>When using scientific format, the <code>digits</code> argument behaves like it does in <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a>; it specifies the number of significant digits.  However, unlike <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a>, when using fixed format, <code>digits</code> is the number of digits after the decimal point.  This is more predictable than <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a>, because the number of places after the decimal is fixed regardless of the values being formatted.</p>
<p><a href="https://www.rdocumentation.org/packages/base/topics/formatC"><code>formatC()</code></a> also formats numbers individually, which means you always get the same output regardless of other numbers in the vector.</p>
<p>The <code>flag</code> argument allows you to provide some modifiers that, for example, force the display of the sign (<code>flag = "+"</code>), left align numbers (<code>flag = "-"</code>) and pad numbers with leading zeros (<code>flag = "0"</code>).  You'll see  an example in this exercise.</p>
</div>
<div class="exercise--instructions__content">
<p>The vectors <code>income</code>, <code>percent_change</code>, and <code>p_values</code> are available in your workspace.</p>

<li>First, compare the behavior of <code>formatC()</code> to <code>format()</code> by calling <code>formatC()</code> on <code>x</code> with <code>format = "f"</code> and <code>digits = 1</code>.  <em>This is the same vector you used with <code>format()</code>, do you see the difference?</em>
</li>
```{r,warning=F,message=F}

```
<li>Call <code>formatC()</code> on <code>y</code> with <code>format = "f"</code> and <code>digits = 1</code>.  <em>Notice how <code>digits</code> has consistent behavior regardless of the vector you format.</em>
</li>
```{r,warning=F,message=F}
# From the format() exercise
x <- c(0.0011, 0.011, 1)
y <- c(1.0011, 2.011, 1)

# formatC() on x with format = "f", digits = 1
formatC(x, format = "f", digits = 1)
# formatC() on y with format = "f", digits = 1
formatC(y, format = "f", digits = 1)
```
<li>Format <code>percent_change</code> to one decimal place after the decimal point.</li>
```{r,warning=F,message=F}
# Format percent_change to one place after the decimal point
formatC(percent_change, format = "f", digits = 1)
```
<li>Format <code>percent_change</code> to one decimal place after the decimal point and add <code>flag = "+"</code>. <em>This forces the display of the sign.</em>
</li>
```{r,warning=F,message=F}
# percent_change with flag = "+"
formatC(percent_change, format = "f", digits = 1, flag = "+")
```
<li>Format <code>p_values</code> using <code>format = "g"</code> and <code>digits = 2</code>. <em>This can be useful, since if there are any p-values in scientific notation, they must be &lt; 0.0001.</em>
</li>
```{r,warning=F,message=F}
# Format p_values using format = "g" and digits = 2
formatC(p_values, format = "g", digits = 2)
```
</div>

<p class="">Awesome job!
</p>

#### Putting strings together {.unnumbered}



##### Annotation of numbers {.unnumbered}


<div class>
<p>To get a handle on using <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a>, you are going to annotate some of your formatted number strings.  </p>
<p>The key points to remember are:</p>
<ul>
<li>The vectors you pass to <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a> are pasted together element by element, using the <code>sep</code> argument to combine them.</li>
<li>If the vectors passed to <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a> aren't the same length, the shorter vectors are recycled up to the length of the longest one.</li>
<li>Only use <code>collapse</code> if you want a single string as output. <code>collapse</code> specifies the string to place between different elements.</li>
</ul>
</div>
<div class="exercise--instructions__content">
<p>We've put the formatted vectors <code>pretty_income</code> and <code>pretty_percent</code> in your workspace along with <code>years</code>.</p>
```{r,warning=F,message=F}
pretty_income=c("72",        "1,030",     "10,292",    "1,189,192")
pretty_percent=c("+4.0", "-1.9", "+3.0", "-5.0")
years=c(2010, 2011, 2012, 2013)
```
<li>Paste a <code>\$</code> to the front of each value in <code>pretty_income</code>, use <code>sep = ""</code>, so there is no space between the <code>\$</code> and value.</li>
```{r,warning=F,message=F}
# Add $ to pretty_income
paste("$", pretty_income, sep = "")
```
<li>Paste a <code>%</code> to the end of each value in <code>pretty_percent</code>, use <code>sep = ""</code>, so there is no space between the value and the <code>%</code>.</li>
```{r,warning=F,message=F}
# Add % to pretty_percent
paste(pretty_percent, "%", sep = "")
```
<li><code>years</code> contains the year each <code>pretty_percent</code> corresponds to.  Use <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a> to produce a vector with elements like <code>2010: +4.0%</code> and assign it to <code>year_percent</code>.</li>
```{r,warning=F,message=F}
# Create vector with elements like 2010: +4.0%`
year_percent <- paste(years, ": ", pretty_percent, "%", sep = "")
```
<li>Use <code>paste()</code> with <code>year_percent</code> to create single string that collapses all the years: <code>2010: +4.0%, 2011: -1.9%, 2012: +3.0%, 2013: -5.0%</code>.</li>
```{r,warning=F,message=F}
# Collapse all years into single string
paste(year_percent, collapse = ", ")
```
</div>

<p class="">Well done!  Specifying <code>sep = ""</code> is so common, there is actually another function <code>paste0()</code> that works like <code>paste()</code> but always pastes elements together without a separator between them.
</p>

##### A very simple table {.unnumbered}


<div class>
<p>Combining <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a> and <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a> is one way to display very simple tables.  Remember, since <a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a> looks at all the values in a vector before formatting, it uses a consistent format and will, by default, align on the decimal point.  This is usually the behavior you want for a column of numbers in table.</p>
<p><a href="https://www.rdocumentation.org/packages/base/topics/format"><code>format()</code></a> can also take character vectors as input. In this case, you can use the  <code>justify</code> argument, specific to character input, to justify the text to the <code>left</code>, <code>right</code>, or <code>center</code>.</p>
<p>You are going to put together the following table:</p>
<pre><code>          Year 0   $       72
          Year 1   $    1,030
          Year 2   $   10,292
Project Lifetime   $1,189,192
</code></pre>
<p>You'll start by formatting the columns to prepare to put them in a table, then you'll use <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a> to put together each row.  Then, you can use <a href="https://www.rdocumentation.org/packages/base/topics/writeLines"><code>writeLines()</code></a> to display each row on a new line.</p>
</div>
<div class="exercise--instructions__content">
<p>The <code>income</code> vector is loaded in your workspace.</p>

<li>Create <code>pretty_income</code> by using <code>format()</code> with <code>digits = 2</code> and <code>big.mark = ","</code>.</li>
```{r,warning=F,message=F}
# Define the names vector
income_names <- c("Year 0", "Year 1", "Year 2", "Project Lifetime")

# Create pretty_income
pretty_income <- format(income, digits = 2, big.mark = ",")
```
<li>Create <code>dollar_income</code> by pasting <code>$</code> to <code>pretty_income</code> (don't forget to set the <code>sep</code> argument). </li>
```{r,warning=F,message=F}
# Create dollar_income
dollar_income <- paste("$", pretty_income, sep = "")
```
<li>Create <code>formatted_names</code> by using <code>format()</code> on <code>income_names</code> with <code>justify = "right"</code>.</li>
```{r,warning=F,message=F}
# Create formatted_names
formatted_names <- format(income_names, justify = "right")
```
<li>Create <code>rows</code> by pasting together <code>formatted_names</code> and <code>dollar_income</code>. Use three spaces as a separator to give some room between your columns. Be sure to surround your separator in <code>"</code>.</li>
```{r,warning=F,message=F}
# Create rows
rows <- paste(formatted_names, dollar_income, sep = "   ")
```
<li>Call <code>writeLines()</code> on <code>rows</code> to see your table.</li>
```{r,warning=F,message=F}
# Write rows
writeLines(rows)
```
</div>

<p class="">Great work! If you wanted the dollar signs right next to the numbers, you could format the incomes with <code>trim = TRUE</code>, paste on the <code>$</code>, then format again as a string with <code>justify  = "right"</code>.
</p>

##### Let's order pizza! {.unnumbered}


<div class>
<p>As a final exercise in using <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a> and to celebrate getting to the end of the first chapter, let's order some pizza.</p>
<p>We've got a list of possible pizza toppings in <code>toppings</code>.</p>
<p>You are going to randomly select three toppings, and then put them together using <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a> into an order for pizza, that should result in a string like,</p>
<pre><code>"I want to order a pizza with mushrooms, spinach, and pineapple."
</code></pre>
</div>
<div class="exercise--instructions__content">
<li>Print <code>my_toppings</code> to see your random toppings. </li>
```{r,warning=F,message=F}
toppings=c("anchovies"
,"artichoke"
,"bacon"
,"breakfast
,bacon"
,"Canadian
,bacon"
,"cheese"
,"chicken"
,"chili
,peppers"
,"feta"
,"garlic"
,"green
,peppers"
,"grilled
,onions"
,"ground
,beef"
,"ham"
,"hot
,sauce"
,"meatballs"
,"mushrooms"
,"olives"
,"onions"
,"pepperoni"
,"pineapple"
,"sausage"
,"spinach"
,"sun-dried
,tomato"
,"tomatoes")
# Randomly sample 3 toppings
my_toppings <- sample(toppings, size = 3)

# Print my_toppings
my_toppings
```
<li>Add <code>"and "</code> to the start of the third element by using <code>paste()</code> with <code>my_toppings</code> and a vector you define.</li>
```{r,warning=F,message=F}
# Paste "and " to last element: my_toppings_and
my_toppings_and <- paste(c("", "", "and "), my_toppings, sep = "")
```
<li>Create a vector <code>these_toppings</code> by using <code>paste()</code> to collapse <code>my_toppings_and</code> with a comma and space between each element.</li>
```{r,warning=F,message=F}
# Collapse with comma space: these_toppings
these_toppings <- paste(my_toppings_and, collapse = ", ")
```
<li>Create <code>my_order</code> by pasting <code>"I want to order a pizza with "</code> to <code>these_toppings</code> and ending with a period, <code>"."</code>.</li>
```{r,warning=F,message=F}
# Add rest of sentence: my_order
my_order <- paste("I want to order a pizza with ", these_toppings, ".", sep = "")
```
<li>Order your pizza by calling <a href="https://www.rdocumentation.org/packages/base/topics/writeLines"><code>writeLines()</code></a> on <code>my_order</code>.</li>
```{r,warning=F,message=F}
# Order pizza with writeLines()
writeLines(my_order)
```
<li>Try re-running all your code (including the sampling of toppings).  You should get a brand new pizza order!</li>
</div>

<p class="">Next time you can't decide what kind of pizza to get, you know what to do!
</p>

### Introduction to stringr {.unnumbered}

<p class="chapter__description">
    Time to meet stringr! You'll start by learning about some stringr functions that are very similar to some base R functions, then how to detect specific patterns in strings, how to split strings apart and how to find and replace parts of strings.
  </p>
  
#### Introducing stringr {.unnumbered}

##### Putting strings together with stringr {.unnumbered}


<div class>
<p>For your first <code>stringr</code> function, we'll look at <a href="https://www.rdocumentation.org/packages/stringr/topics/str_c"><code>str_c()</code></a>, the <code>c</code> is short for <strong>c</strong>oncatenate, a function that works like <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a>. It takes vectors of strings as input along with <code>sep</code> and <code>collapse</code> arguments. </p>
<p>There are two key ways <a href="https://www.rdocumentation.org/packages/stringr/topics/str_c"><code>str_c()</code></a> differs from <a href="https://www.rdocumentation.org/packages/base/topics/paste"><code>paste()</code></a>. First, the default separator is an empty string, <code>sep = ""</code>, as opposed to a space, so it's more like <a href="https://www.rdocumentation.org/packages/base/topics/paste0"><code>paste0()</code></a>. This is an example of a <code>stringr</code> function, performing a similar operation to a <code>base</code> function, but using a default that is more likely to be what you want. Remember in your pizza order, you had to set <code>sep = ""</code> multiple times.</p>
<p>The second way <code>str_c()</code> differs to <code>paste()</code> is in its handling of missing values. <code>paste()</code> turns missing values into the string <code>"NA"</code>, whereas <code>str_c()</code> propagates missing values.  That means combining any strings with a missing value will result in another missing value.</p>
<p>Let's explore this difference using your pizza order from the previous chapter.</p>
</div>
<div class="exercise--instructions__content">
<p>We've set up a new <code>my_toppings</code> vector that has a few missing values and taken the first step of creating our order.</p>

<li>Print <code>my_toppings_and</code> to see what <code>paste()</code> did with the missing values.</li>
```{r,warning=F,message=F}
library(stringr)

my_toppings <- c("cheese", NA, NA)
my_toppings_and <- paste(c("", "", "and "), my_toppings, sep = "")

# Print my_toppings_and
my_toppings_and

```
<li>Repeat the <code>paste()</code> statement but instead use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_c"><code>str_c()</code></a>. You can save some typing by leaving off <code>sep = ""</code> since that is the default. Call this string <code>my_toppings_str</code>.</li>
```{r,warning=F,message=F}
# Use str_c() instead of paste(): my_toppings_str
my_toppings_str <- str_c(c("", "", "and "), my_toppings)
```
<li>Print <code>my_toppings_str</code> to see what <code>str_c()</code> does with the missing values.</li>
```{r,warning=F,message=F}
# Print my_toppings_str
my_toppings_str
```
<li>Take the next step in our order, by using <code>paste()</code> on <code>my_toppings_and</code> with <code>collapse = ", "</code>.</li>
```{r,warning=F,message=F}
# paste() my_toppings_and with collapse = ", "
paste(my_toppings_and, collapse = ", ")
```
<li>Take the next step in our order, by using <code>str_c()</code> on <code>my_toppings_str</code> with <code>collapse = ", "</code>. <em>See the difference: just one <code>NA</code> will make our entire result <code>NA</code>.</em></li>
```{r,warning=F,message=F}
# str_c() my_toppings_str with collapse = ", "
str_c(my_toppings_str, collapse = ", ")
```
</div>

<p class="">Nice work!  This behavior is nice because you learn quickly when you might have missing values, rather than discovering later weird <code>"NA"</code>s inside your strings.  Another <code>stringr</code> function that is useful when you may have missing values, is <code>str_replace_na()</code> which replaces missing values with any string you choose.
</p>

##### String length {.unnumbered}


<div class>
<p>Our next <code>stringr</code> function is <a href="https://www.rdocumentation.org/packages/stringr/topics/str_length"><code>str_length()</code></a>. <code>str_length()</code> takes a vector of strings as input and returns the number of characters in each string. For example, try finding the number of characters in Batman's name:</p>
<pre><code>str_length(c("Bruce", "Wayne"))
</code></pre>
<p>This is very similar to the <code>base</code> function <a href="https://www.rdocumentation.org/packages/base/topics/nchar"><code>nchar()</code></a> but you'll see in the exercises <code>str_length()</code> handles factors in an intuitive way, whereas <code>nchar()</code> will just return an error.  </p>
<p>Historically, <code>nchar()</code> was even worse, rather than returning an error if you passed it a factor, it would return the number of characters in the numeric encoding of the factor. Thankfully this behavior has been fixed, but it was one of the original motivations behind <code>str_length()</code>.  </p>
<p>Take your first look at <code>babynames</code> by asking if girls' names are longer than boys' names.</p>
</div>
<div class="exercise--instructions__content">
<p>We've pulled out just the names from 2014, and created the vectors <code>boy_names</code> and <code>girl_names</code> for you.  (If you want to learn about the <code>filter()</code> function, take the <a href="https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial"><em>Data Manipulation in R with dplyr</em></a> course!).</p>

<li>Take a look at the <code>boy_names</code> vector, it's long, so use <code>head()</code> to see the first few elements.</li>
```{r,warning=F,message=F}
library(stringr)
library(babynames)
library(dplyr)

# Extracting vectors for boys' and girls' names
babynames_2014 <- filter(babynames, year == 2014)
boy_names <- filter(babynames_2014, sex == "M")$name
girl_names <- filter(babynames_2014, sex == "F")$name

# Take a look at a few boy_names
head(boy_names)
```
<li>Use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_length"><code>str_length()</code></a> on <code>boy_names</code> to find the length of each name and save the result to <code>boy_length</code>.</li>
```{r,warning=F,message=F}
# Find the length of all boy_names
boy_length <- str_length(boy_names)

```
<li>Take a look at the lengths. Again, use <code>head()</code>.  <em>Can you see the correspondence with <code>boy_names</code>?</em>
</li>
```{r,warning=F,message=F}
# Take a look at a few lengths
head(boy_length)
```
<li>Find the length of all the girls' names. Call this <code>girl_length</code>.</li>
```{r,warning=F,message=F}
# Find the length of all girl_names
girl_length <- str_length(girl_names)
```
<li>Find the difference in mean length between boys' and girls' names by subtracting the mean length of boys' names from that of girls' names.</li>
```{r,warning=F,message=F}
# Find the difference in mean length
mean(girl_length) - mean(boy_length)
```
<li>Confirm <code>str_length()</code> works on factors, by calling it on <code>factor(boy_names)</code>. Again, you'll want to just look at the <code>head()</code>.</li>
```{r,warning=F,message=F}
# Confirm str_length() works with factors
head(str_length(factor(boy_names)))
```
</div>

<p class="">Fantastic! The average length of the girls' names in 2014 is about 1/3 of a character longer. Just be aware this is a naive average where each name is counted once, not weighted by how many babies received the name.  A better comparison might be an average weighted by the <code>n</code> column in <code>babynames</code>.
</p>

##### Extracting substrings {.unnumbered}


<div class>
<p>The <a href="https://www.rdocumentation.org/packages/stringr/topics/str_sub"><code>str_sub()</code></a> function in <code>stringr</code> extracts parts of strings based on their location.  As with all <code>stringr</code> functions, the first argument, <code>string</code>, is a vector of strings.  The arguments <code>start</code> and <code>end</code> specify the boundaries of the piece to extract in characters.</p>
<p>For example, <code>str_sub(x, 1, 4)</code> asks for the substring starting at the first character, up to the fourth character, or in other words the first four characters.  Try it with my Batman's name:</p>
<pre><code>str_sub(c("Bruce", "Wayne"), 1, 4)
</code></pre>
<p>Both <code>start</code> and <code>end</code> can be negative integers, in which case, they count from the end of the string.  For example, <code>str_sub(x, -4, -1)</code>, asks for the substring starting at the fourth character from the end, up to the first character from the end, i.e. the last four characters.  Again, try it with Batman:</p>
<pre><code>str_sub(c("Bruce", "Wayne"), -4, -1)
</code></pre>
<p>To practice, you'll use <code>str_sub()</code> to look at popular first and last letters for names.</p>
</div>
<div class="exercise--instructions__content">
<p>We've set up the same <code>boy_names</code> and <code>girl_names</code> vectors from the last exercise in your workspace.</p>

<li>Use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_sub"><code>str_sub()</code></a> to extract the first letter of each name in <code>boy_names</code>. Save this to <code>boy_first_letter</code>. </li>
```{r,warning=F,message=F}
# Extract first letter from boy_names
boy_first_letter <- str_sub(boy_names, 1, 1)
```
<li>Use <a href="https://www.rdocumentation.org/packages/base/topics/table"><code>table()</code></a> on <code>boy_first_letter</code> to count up how many names start with each letter. <em>Can you see which is most popular?</em></li>
```{r,warning=F,message=F}
# Tabulate occurrences of boy_first_letter
table(boy_first_letter) 
```
<li>Repeat these steps, but now look at the last letter for boys' names.</li>
```{r,warning=F,message=F}
# Extract the last letter in boy_names, then tabulate
boy_last_letter <- str_sub(boy_names, -1, -1)
table(boy_last_letter) 
```
<li>Again repeat, but now look at the first letter for girls' names.</li>
```{r,warning=F,message=F}
# Extract the first letter in girl_names, then tabulate
girl_first_letter <- str_sub(girl_names, 1, 1)
table(girl_first_letter) 
```
<li>Finally, look at the last letter for girls' names.</li>
```{r,warning=F,message=F}
# Extract the last letter in girl_names, then tabulate
girl_last_letter <- str_sub(girl_names, -1, -1)
table(girl_last_letter)
```
</div>

<p class="">Great job!  Did you see that <code>"A"</code> is the most popular first letter for both boys and girls, and the most popular last letter for girls.  However, the most popular last letter for boys' names was <code>"n"</code>. You might have seen <code>substr()</code> a base R function that is similar to <code>str_sub()</code>.  The big advantage of <code>str_sub()</code> is the ability to use negative indexes to count from the end of a string.
</p>

#### Hunting for matches {.unnumbered}



##### Detecting matches {.unnumbered}


<div class>
<p><a href="https://www.rdocumentation.org/packages/stringr/topics/str_detect"><code>str_detect()</code></a> is used to answer the question: Does the string contain the pattern?
It returns a logical vector of the same length as that of the input vector <code>string</code>, with <code>TRUE</code> for elements that contain the pattern and <code>FALSE</code> otherwise.</p>
<p>Let's take a look at a simple example where you have a vector of strings that represent pizza orders:</p>
<pre><code>pizzas &lt;- c("cheese", "pepperoni", 
  "sausage and green peppers")
</code></pre>
<p>You can ask which orders contain the pattern <code>"pepper"</code>, with</p>
<pre><code>str_detect(pizzas, 
  pattern = fixed("pepper"))
</code></pre>
<p>Try it out!  You should get <code>FALSE TRUE TRUE</code>. Notice how both <strong>pepper</strong>oni and green <strong>pepper</strong>s contain the pattern of interest.</p>
<p>The output from <code>str_detect()</code> can be used to count the number of occurrences, or to subset out the strings that contain the pattern.  You'll practice both to find the boys' names that contain <code>"zz"</code>.</p>
</div>
<div class="exercise--instructions__content">

<li>Use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_detect"><code>str_detect()</code></a> to find which <code>boy_names</code> contain <code>"zz"</code>. Save the result to <code>contains_zz</code>.</li>
```{r,warning=F,message=F}

 # Look for pattern "zz" in boy_names
contains_zz <- str_detect(boy_names, fixed("zz"))
```
<li>Examine the structure of  <code>contains_zz</code> with <code>str()</code>.  <em>It should be a logical vector the same length as <code>boy_names</code>.</em>
</li>
```{r,warning=F,message=F}
# Examine str() of contains_zz
str(contains_zz)
```
<li>To find out how many names in <code>boy_names</code> contain <code>"zz"</code>, use <code>sum()</code> on <code>contains_zz</code>. <em>Recall summing a logical vector counts how many are <code>TRUE</code>.</em>
</li>
```{r,warning=F,message=F}
# How many names contain "zz"?
sum(contains_zz)
```
<li>To find the names in <code>boy_names</code> that contain <code>"zz"</code>, subset <code>boy_names</code> using <code>[</code> and <code>contains_zz</code>.</li>
```{r,warning=F,message=F}
# Which names contain "zz"?
boy_names[contains_zz]
```
<li>We've also included <code>boy_df</code> in your workspace, a data frame that corresponds to the boys' names in 2014.  Subset the rows of <code>boy_df</code> using <code>contains_zz</code>.</li>
```{r,warning=F,message=F}
# Which rows in boy_df have names that contain "zz"?
boy_df <- filter(babynames_2014, sex == "M")
# Which rows in boy_df have names that contain "zz"?
boy_df[contains_zz, ]
```
</div>

<p class="">That last example is another common use of <code>str_detect()</code> subsetting a data frame to rows where the values in a column contain the pattern of interest.  In this case it lets us see these double-z names are pretty rare. For example, even the most popular, Uzziah, only accounted for 0.003% of boys born in 2014.
</p>

##### Subsetting strings based on match {.unnumbered}


<div class>
<p>Since detecting strings with a pattern and then subsetting out those strings is such a common operation, <code>stringr</code> provides a function <a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset"><code>str_subset()</code></a> that does that in one step.</p>
<p>For example, let's repeat our search for <code>"pepper"</code> in our <code>pizzas</code> using <code>str_subset()</code>:</p>
<pre><code>pizzas &lt;- c("cheese", "pepperoni", "sausage and green peppers")
str_subset(pizzas, pattern = fixed("pepper"))
</code></pre>
<p>We get a new vector of strings, but it only contains those original strings that contained the pattern.  </p>
<p><a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset"><code>str_subset()</code></a> can be easily confused with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract"><code>str_extract()</code></a>. <code>str_extract()</code> returns a vector of the same length as that of the input vector, but with only the <strong>parts</strong> of the strings that matched the pattern. This won't be very interesting until we know about regular expressions, so we'll talk more about this in Chapter 3.</p>
<p>For now, you'll repeat part of the last exercise using <code>str_subset()</code> and then find a few other interesting names.</p>
</div>
<div class="exercise--instructions__content">
<li>Find the <code>boy_names</code> that contain <code>"zz"</code>, using <a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset"><code>str_subset()</code></a>.</li>
```{r,warning=F,message=F}
# Find boy_names that contain "zz"
str_subset(boy_names, fixed("zz"))
```
<li>Find the <code>girl_names</code> that contain <code>"zz"</code>.</li>
```{r,warning=F,message=F}
# Find girl_names that contain "zz"
str_subset(girl_names, fixed("zz"))
```
<li>Find the <code>girl_names</code> that contain <code>"U"</code> and save into <code>starts_U</code>.  <em>Since the pattern matching is case sensitive, this will only be names that start with <code>"U"</code>.</em>
</li>
```{r,warning=F,message=F}
# Find girl_names that contain "U"
starts_U <- str_subset(girl_names, fixed("U"))
starts_U
```
<li>Feed <code>starts_U</code> into another <code>str_subset()</code> that looks for <code>"z"</code>. <em>Combining multiple <code>str_subset()</code> calls is a way to find more complicated patterns.</em>
</li>
```{r,warning=F,message=F}
# Find girl_names that contain "U" and "z"
str_subset(starts_U, fixed("z"))
```
</div>

<p class="">Nice work! Only one girls' name that starts with <code>"U"</code> and contains a <code>"z"</code>. Have you ever met an “Umaiza”?
</p>

##### Counting matches {.unnumbered}


<div class>
<p>Another <code>stringr</code> function that takes a vector of strings and a pattern is <a href="https://www.rdocumentation.org/packages/stringr/topics/str_count"><code>str_count()</code></a>. <code>str_count()</code> answers the question "How many times does the pattern occur in each string?". It always returns an integer vector of the same length as that of the input vector.</p>
<p>If you count the occurrences of <code>"pepper"</code> in your <code>pizzas</code>, you'll find no occurrences in the first, and one each in the second and third,</p>
<pre><code>pizzas &lt;- c("cheese", "pepperoni", 
  "sausage and green peppers")
str_count(pizzas, pattern = fixed("pepper"))
</code></pre>
<p>Perhaps a little more interesting is to count how many <code>"e"</code>s occur in each order</p>
<pre><code>str_count(pizzas, pattern = fixed("e"))
</code></pre>
<p>You'll use <code>str_count()</code> to find some names with lots of repeated letters.</p>
</div>
<div class="exercise--instructions__content">
<li>Count the number of <code>"a"</code> in each <code>girl_names</code>, store in <code>number_as</code>.</li>
```{r,warning=F,message=F}
# Count occurrences of "a" in girl_names
number_as <- str_count(girl_names, fixed("a"))
```
<li>Count the number of <code>"A"</code> in each <code>girl_names</code>, store in <code>number_As</code>.</li>
```{r,warning=F,message=F}
# Count occurrences of "A" in girl_names
number_As <- str_count(girl_names, fixed("A"))
```
<li>Create histograms, use the <a href="https://www.rdocumentation.org/packages/graphics/topics/hist"><code>hist()</code></a> function, of <code>number_as</code> and <code>number_As</code>. <em>Why is <code>number_As</code> only zero or one?</em>
</li>
```{r,warning=F,message=F}
# Histograms of number_as and number_As
hist(number_as)
hist(number_As)
```
<li>Add together <code>number_as</code> and <code>number_As</code> to get <code>total_as</code>.</li>
```{r,warning=F,message=F}
# Find total "a" + "A"
total_as <- number_as + number_As
```
<li>Subset <code>girl_names</code> to only those names where <code>total_as &gt; 4</code>.</li>
```{r,warning=F,message=F}
# girl_names with more than 4 a's
girl_names[total_as > 4]
```
</div>

<p class="">Excellent work!
</p>

#### Splitting strings {.unnumbered}



##### Parsing strings into variables {.unnumbered}


<div class>
<p>A common use for <a href="https://www.rdocumentation.org/packages/stringr/topics/str_split"><code>str_split()</code></a> is to pull apart raw string data into more useful variables.  In this exercise you'll start by pulling apart a date range, something like <code>"23.01.2017 - 29.01.2017"</code>, into separate variables for the start of the range, <code>"23.01.2017"</code>, and the end of the range, <code>"29.01.2017"</code>.  </p>
<p>Remember, if the <code>simplify</code> argument is <code>FALSE</code> (the default) you'll get back a list of the same length as that of the input vector.  More commonly, you'll want to pull out the first piece (or second piece etc.) from every element, which is easier if you specify <code>simplify = TRUE</code> and get a matrix as output.  You'll explore both of these output types in this exercise.</p>
</div>
<div class="exercise--instructions__content">
<p>Split <code>date_ranges</code> using <code>" - "</code> as a pattern, assign this to <code>split_dates</code>. Don't forget to wrap the pattern in <a href="https://www.rdocumentation.org/packages/stringr/topics/modifiers"><code>fixed()</code></a>. Print <code>split_dates</code>.  <em>The result is a list with two elements, since <code>date_ranges</code> was a vector of length two.</em></p></div>
```{r,warning=F,message=F}
# Some date data
date_ranges <- c("23.01.2017 - 29.01.2017", "30.01.2017 - 06.02.2017")

# Split dates using " - "
split_dates <- str_split(date_ranges, fixed(" - "))
split_dates
```
<p>Now, split <code>date_ranges</code> again, but specify <code>simplify = TRUE</code> and <code>n = 2</code>.  Print the result to see the difference.  <em>Now we get a matrix back, where each row corresponds to an element of <code>date_ranges</code>.</em></p>
```{r,warning=F,message=F}
# Some date data
date_ranges <- c("23.01.2017 - 29.01.2017", "30.01.2017 - 06.02.2017")

# Split dates with n and simplify specified
split_dates_n <- str_split(date_ranges, fixed(" - "), n = 2, simplify = TRUE)
split_dates_n
```
<div class="exercise--instructions__content"><ul>
<li>Pull out the first column of <code>split_dates_n</code> into <code>start_dates</code>.</li>
<li>Split <code>start_dates</code> into its day, month and year components.  You are aiming for a three column matrix as the result.</li>
</ul></div>
```{r,warning=F,message=F}
# From previous step
date_ranges <- c("23.01.2017 - 29.01.2017", "30.01.2017 - 06.02.2017")
split_dates_n <- str_split(date_ranges, fixed(" - "), n = 2, simplify = TRUE)

# Subset split_dates_n into start_dates and end_dates
start_dates <- split_dates_n[ , 1]

# Split start_dates into day, month and year pieces
str_split(start_dates, fixed("."), n = 3, simplify = TRUE)
```
<div class="exercise--instructions__content"><p>Now you're on your own.  We've provided the <code>both_names</code> vector, listing a couple of famous statisticians.  Your job is to pull out the first names and last names into separate vectors.  You'll need to use an intermediate variable, <code>both_names_split</code>.</p></div>
```{r,warning=F,message=F}
both_names <- c("Box, George", "Cox, David")

# Split both_names into first_names and last_names
both_names_split <- str_split(both_names, fixed(", "), n = 2, simplify = TRUE)

# Get first names
first_names <- both_names_split[, 2]

# Get last names
last_names <- both_names_split[, 1]
```

<p class="">Super splitting! Use the <code>simplify = TRUE</code> argument when you want to split each string into the same number of pieces.
</p>

##### Some simple text statistics {.unnumbered}


<div class>
<p>Generally, specifying <code>simplify = TRUE</code> will give you output that is easier to work with, but you'll always get <code>n</code> pieces (even if some are empty, <code>""</code>). </p>
<p>Sometimes, you want to know how many pieces a string can be split into, or you want to do something with every piece before moving to a simpler structure. This is a situation where you don't want to simplify and you'll have to process the output with something like <a href="https://www.rdocumentation.org/packages/base/topics/lapply"><code>lapply()</code></a>. </p>
<p>As an example, you'll be performing some simple text statistics on your lines from <em>Alice's Adventures in Wonderland</em> from Chapter 1. Your goal will be to calculate how many words are in each line, and the average length of words in each line.</p>
<p>To do these calculations, you'll need to split the lines into words.  One way to break a sentence into words is to split on an empty space <code>" "</code>.  This is a little naive because, for example, it wouldn't pick up words separated by a newline escape sequence like in <code>"two\nwords"</code>, but since this situation doesn't occur in your lines, it will do.</p>
</div>
<div class="exercise--instructions__content">
<p>We've put <code>lines</code> a vector with three strings, each corresponding to a line in your workspace.</p>

<li>Split <code>lines</code> into words. Assign the resulting list to <code>words</code>.</li>
```{r,warning=F,message=F}
# Split lines into words
words <- str_split(lines, " ")
```
<li>Use <a href="https://www.rdocumentation.org/packages/base/topics/lapply"><code>lapply()</code></a> to apply <a href="https://www.rdocumentation.org/packages/base/topics/length"><code>length()</code></a> to each element in <code>words</code> to count the number of words in each line.</li>
```{r,warning=F,message=F}
# Number of words per line
lapply(words, length)
```
<li>Use <code>lapply()</code> to apply <a href="https://www.rdocumentation.org/packages/stringr/topics/str_length"><code>str_length()</code></a> to each element in <code>words</code>, to count the number of characters in each word. Assign this to <code>word_lengths</code>.</li>
```{r,warning=F,message=F}
# Number of characters in each word
word_lengths <- lapply(words, str_length)
```
<li>Use <code>lapply()</code> to apply <a href="https://www.rdocumentation.org/packages/base/topics/mean"><code>mean()</code></a> to each element in <code>word_lengths</code>, to find the average word length in each line.</li>
```{r,warning=F,message=F}
# Average word length per line
lapply(word_lengths, mean)
```
</div>

<p class="">Nice work! The word lengths aren't quite right because you were including some punctuation symbols.  One way to deal with that is to replace them first with <code>str_replace()</code>, which just happens to be the next function you'll learn about.
</p>

#### Replacing matches in strings {.unnumbered}



##### Replacing to tidy strings {.unnumbered}


<div class>
<p>You've seen one common strategy to pull variables out of strings is to split the string based on a pattern.  Sometimes, it's easier to just replace the parts you don't want with an empty string <code>""</code>.  This is also a common strategy to clean strings up, for example, to remove unwanted punctuation or white space.</p>
<p>In this exercise you'll pull out some numbers by replacing the part of the string that isn't a number, you'll also play with the format of some phone numbers. Pay close attention to the difference between <a href="https://www.rdocumentation.org/packages/stringr/topics/str_replace"><code>str_replace()</code></a> and <code>str_replace_all()</code>.</p>
</div>
<div class="exercise--instructions__content">
<li>Keep the numeric part of <code>ids</code>, by replacing <code>"ID#: "</code> with an empty string <code>""</code>.</li>
```{r,warning=F,message=F}
# Some IDs
ids <- c("ID#: 192", "ID#: 118", "ID#: 001")

# Replace "ID#: " with ""
id_nums <- str_replace(ids, fixed("ID#: "), "")
```
<li>Turn the ID strings to numbers using <a href="https://www.rdocumentation.org/packages/base/topics/numeric"><code>as.numeric()</code></a>, assign the result to <code>id_ints</code>.</li>
```{r,warning=F,message=F}
# Turn id_nums into numbers
id_ints <- as.numeric(id_nums)
```
</div>

<div class="exercise--instructions__content">
<li>Use <code>str_replace()</code> on <code>phone_numbers</code> to replace the <code>"-"</code> with a space, <code>" "</code>. <em>Take a close look at the output, are there still some <code>"-"</code>s?</em>
</li>
```{r,warning=F,message=F}
# Some (fake) phone numbers
phone_numbers <- c("510-555-0123", "541-555-0167")

# Use str_replace() to replace "-" with " "
str_replace(phone_numbers, fixed("-"), " ")
```
<li>Repeat the previous task but now use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_replace_all"><code>str_replace_all()</code></a>. <em>Notice the difference, all the <code>"-"</code>s are replaced!</em></li>
```{r,warning=F,message=F}
# Use str_replace_all() to replace "-" with " "
str_replace_all(phone_numbers, fixed("-"), " ")
```
<li>Reformat the phone numbers to use dots instead of dashes, i.e. in the format <code>xxx.xxx.xxxx</code>.</li>
```{r,warning=F,message=F}
# Turn phone numbers into the format xxx.xxx.xxxx
str_replace_all(phone_numbers, fixed("-"), ".")
```
</div>

<p class="">Nice work! If you need to replace multiple characters you could use <code>str_replace_all()</code> more than once, but you'll see a better way of specifying a range of characters to replace once you've learned about regular expressions in Chapter 3.
</p>

##### Review {.unnumbered}


<div class>
<p>You've covered a lot of <code>stringr</code> functions in this chapter:</p>
<ul>
<li><a href="https://www.rdocumentation.org/packages/stringr/topics/str_c"><code>str_c()</code></a></li>
<li><a href="https://www.rdocumentation.org/packages/stringr/topics/str_length"><code>str_length()</code></a></li>
<li><a href="https://www.rdocumentation.org/packages/stringr/topics/str_sub"><code>str_sub()</code></a></li>
<li><a href="https://www.rdocumentation.org/packages/stringr/topics/str_detect"><code>str_detect()</code></a></li>
<li><a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset"><code>str_subset()</code></a></li>
<li><a href="https://www.rdocumentation.org/packages/stringr/topics/str_count"><code>str_count()</code></a></li>
<li><a href="https://www.rdocumentation.org/packages/stringr/topics/str_split"><code>str_split()</code></a></li>
<li><a href="https://www.rdocumentation.org/packages/stringr/topics/str_replace"><code>str_replace()</code></a></li>
</ul>
<p>As a review we've got a few tasks for you to do with some DNA sequences.  We've put three sequences, corresponding to three genes, from the genome of <a href="https://www.ncbi.nlm.nih.gov/genome/153?genome_assembly_id=299265">Yersinia pestis</a> – the bacteria that causes bubonic plague – into the vector <code>genes</code>.</p>
```{r,warning=F,message=F}
genes <- readRDS("archive/String-Manipulation-with-stringr-in-R/dna.rds")

# Find the number of nucleotides in each sequence
str_length(genes)
```
<p>Each string represents a gene, each character a particular nucleotide: <strong>A</strong>denine, <strong>C</strong>ytosine, <strong>G</strong>uanine or <strong>T</strong>hymine.</p>
<p>We aren't going to tell you which function to use.  It's up to you to choose the right one and specify the needed arguments. Good luck!</p>
</div>
<div class="exercise--instructions__content">
<li>Find the number of nucleotides in each gene.</li>
```{r,warning=F,message=F}
# Find the number of nucleotides in each sequence
str_length(genes)
```
<li>Find the number of <code>A</code>'s that occur in each gene.</li>
```{r,warning=F,message=F}
# Find the number of A's occur in each sequence
str_count(genes, fixed("A"))
```
<li>Return the sequences that contain the sequence <code>"TTTTTT"</code>.</li>
```{r,warning=F,message=F}
# Return the sequences that contain "TTTTTT"
str_subset(genes, fixed("TTTTTT"))
```
<li>Replace all the <code>A</code>s in the sequences with a <code>_</code>.</li>
```{r,warning=F,message=F}
# Replace all the "A"s in the sequences with a "_"
str_replace_all(genes, fixed("A"), "_")
```
</div>

<p class="">Great work!
</p>

##### Final challenges {.unnumbered}


<div class>
<p>You've mastered using <code>stringr</code> functions on their own, but by combining multiple operations together in sequence you can achieve quite complicated manipulations.</p>
<p>As the final exercise we want to expose you to the power of combining operations. 
You'll complete two tasks: </p>
<ol>
<li><p>You'll turn a vector of full names, like <code>"Bruce Wayne"</code>, into abbreviated names like <code>"B. Wayne"</code>.  This requires combining <a href="https://www.rdocumentation.org/packages/stringr/topics/str_split"><code>str_split()</code></a>, <a href="https://www.rdocumentation.org/packages/stringr/topics/str_sub"><code>str_sub()</code></a> and <a href="https://www.rdocumentation.org/packages/stringr/topics/str_c"><code>str_c()</code></a>.</p></li>
<li><p>You'll compare how many boy names end in <code>"ee"</code> compared to girl names.  This requires combining <a href="https://www.rdocumentation.org/packages/stringr/topics/str_sub"><code>str_sub()</code></a> with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_detect"><code>str_detect()</code></a> along with the base function <a href="https://www.rdocumentation.org/packages/base/topics/table"><code>table()</code></a>.</p></li>
</ol>
</div>
<div class="exercise--instructions__content">
<li>Use <code>str_split()</code> to create a two column matrix with the first names in one column and the last names in the other.  <em>You'll be manipulating the first name before combining it back with the second name in the next few steps.</em>
</li>
```{r,warning=F,message=F}
# Define some full names
names <- c("Diana Prince", "Clark Kent")

# Split into first and last names
names_split <- str_split(names, fixed(" "), simplify = TRUE)
```
<li>Create an abbreviation of the first name, <code>abb_first</code>, by extracting just the first character with <code>str_sub()</code>. </li>
```{r,warning=F,message=F}
# Extract the first letter in the first name
abb_first <- str_sub(names_split[, 1], 1, 1)
```
<li>Use <code>str_c()</code> to combine <code>abb_first</code> with <code>". "</code> and the last name column to finish the task!</li>
```{r,warning=F,message=F}
# Combine the first letter ". " and last name
str_c(abb_first, ". ", names_split[, 2])
```
</div>

<div class="exercise--instructions__content">
<li>Use <code>str_sub()</code> to extract the last two letters from <code>all_names</code>.</li>
```{r,warning=F,message=F}
# Use all names in babynames_2014
all_names <- babynames_2014$name
```
<li>Create a logical, <code>ends_in_ee</code> that identifies whether the <code>last_two_letters</code> are <code>ee</code>, using <code>str_detect()</code>.</li>
```{r,warning=F,message=F}
# Get the last two letters of all_names
last_two_letters <- str_sub(all_names, -2, -1)
```
<li>Subset the rows of <code>babynames_2014</code> using <code>ends_in_ee</code> and keep only the <code>sex</code> column. (Use the <code>$</code> notation to subset the <code>sex</code> column.)</li>
```{r,warning=F,message=F}
# Does the name end in "ee"?
ends_in_ee <- str_detect(last_two_letters, "ee")

# Extract rows and "sex" column
sex <- babynames_2014$sex[ends_in_ee]
```
<li>Apply <code>table()</code> to the result to complete the task!</li>
```{r,warning=F,message=F}
# Display result as a table
table(sex)
```
</div>

<p class="">Challenge completed! Now you'll learn how to specify patterns in text, using regular expressions.
</p>

### Pattern matching with regex {.unnumbered}

<p class="chapter__description">
    In this chapter you'll learn about regular expressions, a language for describing patterns in strings.  By combining regular expressions with the stringr functions you'll greatly increase your power to manipulate strings.
  </p>
  
#### Regular expressions {.unnumbered}



##### Matching the start or end of the string {.unnumbered}


<div class>
<p><code>rebus</code> provides <a href="https://www.rdocumentation.org/packages/rebus.base/topics/Anchors"><code>START</code></a> and <code>END</code> shortcuts to specify regular expressions that match the start and end of the string. These are also known as <em>anchors</em>. You can try it out just by typing</p>
```{r,warning=F,message=F}
library(rebus)
```
<pre><code>START
</code></pre>
<p>You'll see the output <code>&lt;regex&gt; ^</code>.  The <code>&lt;regex&gt;</code> denotes this is a special <code>regex</code> object and it has the value <code>^</code>.  <code>^</code> is the character used in the regular expression language to denote the start of a string.</p>
<p>The special operator provided by <code>rebus</code>, <code>%R%</code> allows you to compose complicated regular expressions from simple pieces.  When you are reading <code>rebus</code> code, think of <code>%R%</code> as "then".  For example, you could combine <code>START</code> with <code>c</code>,</p>
<pre><code>START %R% "c"
</code></pre>
<p>to match the pattern "the start of string then a <code>c</code>", or in other words: strings that start with <code>c</code>.  In <code>rebus</code>, if you want to match a specific character, or a specific sequence of characters, you simply specify them as a string, e.g. surround them with <code>"</code>.</p>
</div>
<div class="exercise--instructions__content"><ul>
<li>
<em>Which character is used to match the end of a string?</em> Print <code>END</code> to find out.</li>
```{r,warning=F,message=F}
# Some strings to practice with
x <- c("cat", "coat", "scotland", "tic toc")

# Print END
END
```
<li>
<a href="https://www.rdocumentation.org/packages/stringr/topics/str_view"><code>str_view()</code></a> from <code>stringr</code> is really helpful for testing your patterns.  Run this line of code to see the matches in <code>x</code> to the pattern <code>START %R% "c"</code>.</li>
```{r,warning=F,message=F}
library(htmlwidgets)
# Run me
str_view(x, pattern = START %R% "c")
```
</div>

<div class="exercise--instructions__content"><p>Provide the pattern argument to match strings that start in <code>"co"</code>.</p></div>
```{r,warning=F,message=F}
# Match the strings that start with "co" 
str_view(x, pattern = START %R% "co")
```
<div class="exercise--instructions__content"><p>Provide the pattern argument to match strings that end in <code>"at"</code>.  <em>Think about this as matching an <code>"at"</code> followed by the end of the string.</em></p></div>
```{r,warning=F,message=F}
# Match the strings that end with "at"
str_view(x, pattern = "at" %R% END)
```
<div class="exercise--instructions__content"><p>Provide the pattern argument to match strings that are <code>"cat"</code> exactly.  <em>Think about this as matching the start of the string, followed by <code>"cat"</code> and then the end of the string.</em></p></div>
```{r,warning=F,message=F}
# Match the string that is exactly "cat"
str_view(x, pattern = START %R% "cat" %R% END)
```

<p class="">Nice job on your first regular expressions!  For that last example, <code>rebus</code> also provides the function <code>exactly(x)</code> which is a shortcut for <code>START %R% x %R% END</code> that matches only if the string is exactly <code>x</code>.
</p>

##### Matching any character {.unnumbered}


<div class>
<p>In a regular expression you can use a wildcard to match a single character, no matter what the character is.  In <code>rebus</code> it is specified with <a href="https://www.rdocumentation.org/packages/rebus.base/topics/CharacterClasses"><code>ANY_CHAR</code></a>.  Try typing <code>ANY_CHAR</code> in the console. You should see that in the regular expression language this is specified by a dot, <code>.</code>.  </p>
<p>For example, <code>"c" %R% ANY_CHAR %R% "t"</code> will look for patterns like "c_t" where the blank can be any character. Consider the strings: <code>"cat"</code>, <code>"coat"</code>, <code>"scotland"</code> and <code>"tic toc"</code>. Where would the matches to <code>"c" %R% ANY_CHAR %R% "t"</code> be?</p>
<p>Test your intuition by running:</p>
<pre><code>str_view(c("cat", "coat", "scotland", "tic toc"), 
  pattern = "c" %R% ANY_CHAR %R% "t")
</code></pre>
<p>Notice that <code>ANY_CHAR</code> will match a space character (<code>c t</code> in <code>tic toc</code>).  It will also match numbers or punctuation symbols, but <code>ANY_CHAR</code> will only ever match one character, which is why we get no match in <code>coat</code>.</p>
</div>
<div class="exercise--instructions__content"><p>Match any character followed by a <code>t</code>.</p></div>
```{r,warning=F,message=F}
# Match two characters, where the second is a "t"
str_view(x, pattern = ANY_CHAR %R% "t")
```
<div class="exercise--instructions__content"><p>Match a <code>t</code> followed by any character.  <em>Notice how the final <code>t</code> in <code>cat</code> and <code>coat</code> don't match, that's because there is no character after the <code>t</code> to match to <code>ANY_CHAR</code>.</em></p></div>
```{r,warning=F,message=F}
# Match a "t" followed by any character
str_view(x, pattern = "t" %R% ANY_CHAR)
```
<div class="exercise--instructions__content"><p>Match any two characters.  <em>Notice the first two characters are matched.  Regular expressions are lazy and will take the first match they find.</em></p></div>
```{r,warning=F,message=F}
# Match two characters
str_view(x, pattern = ANY_CHAR %R% ANY_CHAR)
```
<div class="exercise--instructions__content"><p>Match a string that is exactly three characters.</p></div>
```{r,warning=F,message=F}
# Match a string with exactly three characters
str_view(x, pattern = START %R% ANY_CHAR %R% ANY_CHAR %R% ANY_CHAR %R% END)
```

<p class="">Nice one!
</p>

##### Combining with stringr functions {.unnumbered}


<div class>
<p>You can pass a regular expression as the <code>pattern</code> argument to any <code>stringr</code> function that has the <code>pattern</code> argument.  You can use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_detect"><code>str_detect()</code></a> to get a logical vector for whether there was a match, <a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset"><code>str_subset()</code></a> to return just the strings with matches, and <a href="https://www.rdocumentation.org/packages/stringr/topics/str_count"><code>str_count()</code></a> to count the number of matches in each string.</p>
<p>As a reminder, compare the output of those three functions with our "c_t" pattern from the previous exercise:</p>
<pre><code>x &lt;- c("cat", "coat", "scotland", "tic toc")
pattern &lt;- "c" %R% ANY_CHAR %R% "t"
str_detect(x, pattern)
str_subset(x, pattern)
str_count(x, pattern)
</code></pre>
<p>It now also makes sense to add <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract"><code>str_extract()</code></a> to your repertoire. It returns just the part of the string that matched the pattern:</p>
<pre><code>str_extract(x, pattern)
</code></pre>
<p>You'll combine your regular expression skills with <code>stringr</code> to ask how often a <code>q</code> is followed by any character in boy names.</p>
<p>It's always a good idea to test your pattern, so this pattern is shown matched with four names.  <em>The first two shouldn't have matches (can you explain why?) but the last two should.</em></p>
</div>
<div class="exercise--instructions__content">
<li>Find the <code>boy_names</code> with the pattern by using  <a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset"><code>str_subset()</code></a>. Assign the result to <code>names_with_q</code>.  </li>
```{r,warning=F,message=F}
pattern <- "q" %R% ANY_CHAR

# Find names that have the pattern
names_with_q <- str_subset(boy_names, pattern)
```
<li>Run <a href="https://www.rdocumentation.org/packages/base/topics/length"><code>length()</code></a> on the result to find out how many there are.</li>
```{r,warning=F,message=F}
# How many names were there?
length(names_with_q)
```
</div>

<div class="exercise--instructions__content">
<li>Find just the part of <code>boy_names</code> that matched with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract"><code>str_extract()</code></a>. Assign the result to <code>part_with_q</code>.  </li>
```{r,warning=F,message=F}
# Find part of name that matches pattern
part_with_q <- str_extract(boy_names, pattern)
```
<li>Run <a href="https://www.rdocumentation.org/packages/base/topics/table"><code>table()</code></a> on the result to find out how many have <code>qu</code> and how many have other patterns.</li>
```{r,warning=F,message=F}
# Get a table of counts
table(part_with_q)
```
</div>
<div class="exercise--instructions__content">
<li>Check that there weren't any <code>boy_names</code> that might have had the pattern twice (you would have only found the first match) by using <a href="https://www.rdocumentation.org/packages/stringr/topics/str_count"><code>str_count()</code></a>. Assign the result to <code>count_of_q</code>. </li>
```{r,warning=F,message=F}
# Did any names have the pattern more than once?
count_of_q <- str_count(boy_names, pattern)
```
<li>Use <code>table()</code> on the result.</li>
```{r,warning=F,message=F}
# Get a table of counts
table(count_of_q)
```
</div>

<div class="exercise--instructions__content">
<li>Get a logical vector of whether or not each boy's name contains <code>q*</code> by calling <a href="https://www.rdocumentation.org/packages/stringr/topics/str_detect"><code>str_detect()</code></a>. Assign the result to <code>with_q</code>.</li>
```{r,warning=F,message=F}
# Which babies got these names?
with_q <- str_detect(boy_names, pattern)
```
<li>Count the fraction of boy's names containing <code>q*</code> by calculating the <a href="https://www.rdocumentation.org/packages/base/topics/mean"><code>mean()</code></a> of <code>with_q</code>.</li>
```{r,warning=F,message=F}
# What fraction of babies got these names?
mean(with_q)
```
</div>

<p class="">Great job! This strategy of first perfecting the pattern on a small set, and then using it for the real data is really useful.
</p>

#### More regular expressions {.unnumbered}



##### Alternation {.unnumbered}


<div class>
<p>The <code>rebus</code> function <a href="https://www.rdocumentation.org/packages/rebus.base/topics/or"><code>or()</code></a> allows us to specify a set of alternatives, which may be single characters or character strings, to be matched. Each alternative is passed as a separate argument.  </p>
<p>For example, <code>or("grey", "gray")</code> allows us to detect either the American or British spelling:</p>
<pre><code>x &lt;- c("grey sky", "gray elephant")
str_view(x, pattern = or("grey", "gray"))
</code></pre>
<p>Since these two words only differ by one character you could equivalently specify this match with <code>"gr" %R% or("e", "a") %R% "y"</code>, that is "a <code>gr</code> followed by, an <code>e</code> or an <code>a</code>, then a <code>y</code>".</p>
<p>Notice we've added the argument <code>match = TRUE</code> to <a href="https://www.rdocumentation.org/packages/stringr/topics/str_view"><code>str_view()</code></a>, this will only display elements that had a match, which is useful when you are searching over many strings.</p>
</div>
<div class="exercise--instructions__content"><p>Create a pattern that matches <code>Jeffrey</code> or <code>Geoffrey</code> in <code>boy_names</code>. Assign this to <code>whole_names</code>.</p></div>
```{r,warning=F,message=F}
# Match Jeffrey or Geoffrey, another way
common_ending <- or("Je", "Geo") %R% "ffrey"
str_view(boy_names, pattern = common_ending, match = TRUE)
```
<div class="exercise--instructions__content"><p>Create a pattern that matches <code>Je</code> or <code>Geo</code> followed by <code>ffrey</code>. Assign this to <code>common_ending</code>. <em>You should get the same matches as the previous pattern.</em></p></div>
```{r,warning=F,message=F}
# Match Jeffrey or Geoffrey, another way
common_ending <- or("Je", "Geo") %R% "ffrey"
str_view(boy_names, pattern = common_ending, match = TRUE)
```
<div class="exercise--instructions__content"><p>Create a pattern that matches <code>Je</code> or <code>Geo</code>, followed by <code>ff</code>, followed by one of <code>ry</code>, <code>ery</code> <code>rey</code>, or <code>erey</code>. Assign this to <code>by_parts</code>.</p></div>
```{r,warning=F,message=F}
# Match with alternate endings
by_parts <- or("Je", "Geo") %R% "ff" %R% or("ry", "ery", "rey", "erey")
str_view(boy_names, pattern = by_parts, match = TRUE)
```
<div class="exercise--instructions__content"><p>Create a pattern that matches all <code>girl_names</code> that start with <code>C</code> or <code>K</code> followed by <code>ath</code>. Assign this to <code>ckath</code>.</p></div>
```{r,warning=F,message=F}
# Match names that start with Cath or Kath
ckath <- or("C", "K") %R% "ath"
str_view(girl_names, pattern = ckath, match = TRUE)
```

<p class="">Astounding alternation! With a bit of thought, you can match very complicated variations of spellings.
</p>

##### Character classes {.unnumbered}


<div class>
<p>In regular expressions a <em>character class</em> is a way of specifying "match one (and only one) of the following characters".  In <code>rebus</code> you can specify the set of allowable characters using the function <a href="https://www.rdocumentation.org/packages/rebus.base/topics/char_class"><code>char_class()</code></a>.</p>
<p>This is another way you could specify an alternate spelling, for example, specifying "a <code>gr</code> followed by, either an <code>a</code> or <code>e</code>, followed by a <code>y</code>":</p>
<pre><code>x &lt;- c("grey sky", "gray elephant")
str_view(x, pattern = "gr" %R% char_class("ae") %R% "y")
</code></pre>
<p>A negated character class matches "any single character that isn't one of the following", and in <code>rebus</code> is specified with <code>negated_char_class()</code>.</p>
<p>Unlike in other places in a regular expression you don't need to escape characters that might otherwise have a special meaning inside character classes.  If you want to match <code>.</code> you can include <code>.</code> directly, e.g. <code>char_class(".")</code>.  Matching a <code>-</code> is a bit trickier. If you need to do it, just make sure it comes first in the character class.</p>
</div>

<div class="exercise--instructions__content">
<li>Create a character class that contains vowels, <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code> <strong>and their upper case versions</strong>.</li>
```{r,warning=F,message=F}
# Create character class containing vowels
vowels <- char_class("aeiouAEIOU")
```
<li>Print <code>vowels</code>.  <em>In the regular expression language, a character class is put inside <code>[</code>.</em>
</li>
```{r,warning=F,message=F}
# Print vowels
vowels
```
<li>View the matches to the pattern <code>vowels</code> in <code>x</code> with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_view"><code>str_view()</code></a>.  <em>Notice how only the first vowel is matched.</em>
</li>
```{r,warning=F,message=F}
# See vowels in x with str_view()
str_view(x, pattern = vowels)
```
</div>
<div class="exercise--instructions__content"><p>View the matches to the pattern <code>vowels</code> in <code>x</code> with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_view"><code>str_view_all()</code></a>.  <em>Now all matches are highlighted.</em></p></div>
```{r,warning=F,message=F}
# See vowels in x with str_view_all()
str_view_all(x, pattern = vowels)
```
<div class="exercise--instructions__content">

<li>Find the number of vowels in each <code>boy_names</code> by combining <a href="https://www.rdocumentation.org/packages/stringr/topics/str_count"><code>str_count()</code></a> with the <code>vowels</code> pattern.</li>
```{r,warning=F,message=F}
# Number of vowels in boy_names
num_vowels <- str_count(boy_names, pattern = vowels)
```
<li>Find the number of characters in each <code>boy_names</code> with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_length"><code>str_length()</code></a>.</li>
```{r,warning=F,message=F}
# Number of characters in boy_names
name_length <- str_length(boy_names)
```
</div>

<div class="exercise--instructions__content">
<li>Find the average number of vowels in <code>boy_names</code> using the mean of <code>num_vowels</code>.</li>
```{r,warning=F,message=F}
# Calc mean number of vowels
mean(num_vowels)
```
<li>Look at the mean ratio of <code>num_vowels</code> and <code>name_length</code>.</li>
```{r,warning=F,message=F}
# Calc mean fraction of vowels per name
mean(num_vowels / name_length)
```
</div>

<p class="">Nice work! The names in <code>boy_names</code> are on average about 40% vowels.
</p>

##### Repetition {.unnumbered}


<div class>
<p>The <code>rebus</code> functions <a href="https://www.rdocumentation.org/packages/rebus.base/topics/repeated"><code>one_or_more()</code></a>, <code>zero_or_more()</code> and <code>optional()</code> can be used to wrap parts of a regular expression to allow a pattern to match a variable number of times.</p>
<p>Take our <code>vowels</code> pattern from the last exercise. You can pass it to <code>one_or_more()</code> to create the pattern that matches "one or more vowels".  Take a look with these interjections:</p>
<pre><code>x &lt;- c("ow", "ooh", "yeeeah!", "shh")
str_view(x, pattern = one_or_more(vowels))
</code></pre>
<p>You'll see we can match the single <code>o</code> in <code>ow</code>, the double <code>o</code> in <code>ooh</code> and the string of <code>e</code>s followed by the <code>a</code> in <code>yeeeah</code>, but nothing in <code>shh</code> because there isn't a single vowel.</p>
<p>In contrast <code>zero_or_more()</code> will match even if there isn't an occurrence, try</p>
<pre><code>str_view(x, pattern = zero_or_more(vowels))
</code></pre>
<p>Since both <code>yeeeah</code> and <code>shh</code> start without a vowel, they match "zero vowels", and since regular expressions are lazy, they look no further and return the start of the string as a match.</p>
</div>
<div class="exercise--instructions__content"><p>Find <code>boy_names</code> that are only vowels, by combining <code>one_or_more()</code> with <code>vowels</code>. You will need to either specify <code>START</code> and <code>END</code> or use <a href="https://www.rdocumentation.org/packages/rebus.base/topics/Anchors"><code>exactly()</code></a>.</p></div>
```{r,warning=F,message=F}
# Vowels from last exercise
vowels <- char_class("aeiouAEIOU")

# See names with only vowels
str_view(boy_names, 
  pattern = exactly(one_or_more(vowels)), 
  match = TRUE)
```
<div class="exercise--instructions__content">
<li>Create a <code>negated_char_class()</code> that matches anything but a vowel. (<em>Note</em>: <code>negated_char_class(vowels)</code> is not the right answer!)</li>
```{r,warning=F,message=F}
# Use `negated_char_class()` for everything but vowels
not_vowels <- negated_char_class("aeiouAEIOU")
```
<li>Find <code>boy_names</code> that have no vowels, by combining <code>exactly()</code> and  <code>one_or_more()</code> with <code>not_vowels</code>.</li>
```{r,warning=F,message=F}
# See names with no vowels
str_view(boy_names, 
  pattern = exactly(one_or_more(not_vowels)), 
  match = TRUE)
```
</div>

<p class="">Excellent!
</p>

#### Shortcuts {.unnumbered}



##### Hunting for phone numbers {.unnumbered}


<div class>
<p>For your first task you are going to pull out the phone numbers from this vector of contact information:</p>
<pre><code>contact
</code></pre>
```{r,warning=F,message=F}
contact <- c("Call me at 555-555-0191", "123 Main St", 
             "(555) 555 0191", "Phone: 555.555.0191 Mobile: 555.555.0192")
```
<p>You'll assume the phone numbers you are looking for follow the American standard of a three digit area code, a three digit exchange and then a four digit number, but each part could be separated by spaces or various punctuation symbols.</p>
</div>
<div class="exercise--instructions__content"><p>Phone numbers start with three digits. Create a pattern that matches three digits in a row. Use <code>str_view_all()</code> to test your pattern.</p></div>
```{r,warning=F,message=F}
# Create a three digit pattern
three_digits <- DGT %R% DGT %R% DGT

# Test it
str_view_all(contact, pattern = three_digits)
```
<div class="exercise--instructions__content"><p>There might be a range of separators, so make a <code>separator</code> pattern, that uses <a href="https://www.rdocumentation.org/packages/rebus.base/topics/char_class" target="_blank" rel="noopener noreferrer"><code>char_class()</code></a> to combine a character class containing <code>-</code>, <code>.</code>, <code>(</code>, <code>)</code>, and <code></code>.</p></div>
```{r,warning=F,message=F}
# Create a separator pattern
separator <- char_class("-.() ")

# Test it
str_view_all(contact, pattern = separator)
```
<div class="exercise--instructions__content"><p>Put together a pattern to match a whole phone number: an optional open parenthesis (<code>OPEN_PAREN</code>), followed by three digits, followed by zero or more separators, followed by three digits followed by zero or more separators, followed by four digits.</p></div>
```{r,warning=F,message=F}
# Use these components
three_digits <- DGT %R% DGT %R% DGT
four_digits <- three_digits %R% DGT
separator <- char_class("-.() ")

# Create phone pattern
phone_pattern <- optional(OPEN_PAREN) %R% 
  three_digits %R% 
  zero_or_more(separator) %R% 
  three_digits %R% 
  zero_or_more(separator) %R%
  four_digits

        
# Test it           
str_view_all(contact, pattern = phone_pattern)
```

<div class="exercise--instructions__content">
<li>Extract the phone number from <code>contact</code>, using <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract" target="_blank" rel="noopener noreferrer"><code>str_extract</code></a>.</li>
```{r,warning=F,message=F}
# Use this pattern
three_digits <- DGT %R% DGT %R% DGT
four_digits <- three_digits %R% DGT
separator <- char_class("-.() ")
phone_pattern <- optional(OPEN_PAREN) %R% 
  three_digits %R% 
  zero_or_more(separator) %R% 
  three_digits %R% 
  zero_or_more(separator) %R%
  four_digits
```
<li>Try using <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract" target="_blank" rel="noopener noreferrer"><code>str_extract_all()</code></a> instead.  <em>Can you see the difference?</em></li>
```{r,warning=F,message=F}
# Extract phone numbers
str_extract(contact, phone_pattern)

# Extract ALL phone numbers
str_extract_all(contact, phone_pattern)
```
</div>

<p class="">Wow! Great job. We'll see an easy way to extract parts of our match (the numbers for example) in the next chapter. <code>rebus</code> also provides the functions <code>number_range()</code> when you want to extract numbers in a certain range, and <code>datetime()</code> to specify common date patterns.
</p>

##### Extracting age and gender from accident narratives {.unnumbered}


<div class>
<p>Recall from the video, you want to parse out age and gender from accident narratives.  For example, this narrative</p>
<pre><code>19YOM-SHOULDER STRAIN-WAS TACKLED WHILE PLAYING FOOTBALL W/ FRIENDS 
</code></pre>
<p>describes <em>male</em> of age <em>19</em>, and this one</p>
<pre><code>TRIPPED OVER CAT AND LANDED ON HARDWOOD FLOOR. LACERATION ELBOW, LEFT. 33 YOF*
</code></pre>
<p>a <em>female</em> of age <em>33</em>.</p>
<p>You are generally looking for a pattern with a number, something to indicate the units, e.g. <code>YO</code> or <code>YR</code> for years old, or <code>MO</code> for months old, and a character that identifies the gender.  </p>
<p>In this exercise you'll build up a pattern to pull out the part of the narrative that has the age and gender information.  Then, in the next exercise you'll parse out the age and gender into separate variables.</p>
```{r,warning=F,message=F}
narratives <- readRDS("archive/String-Manipulation-with-stringr-in-R/narratives.rds")
```
</div>
<div class="exercise--instructions__content"><p>Create an <code>age</code> pattern that matches one or two digits.  Test your pattern using <code>str_view()</code>.</p></div>
```{r,warning=F,message=F}
# Pattern to match one or two digits
age <- DGT %R% optional(DGT)

# Test it
str_view(narratives, pattern = age)
```
<div class="exercise--instructions__content">
<li>Create a <code>unit</code> pattern that matches an optional space, then one of <code>YO</code>, <code>YR</code> or <code>MO</code>.</li>
```{r,warning=F,message=F}
# Use this pattern
age <- DGT %R% optional(DGT)

# Pattern to match units 
unit <- optional(SPC) %R% or("YO", "YR", "MO")
```
<li>Check your pattern so far by using <code>str_view()</code> with the pattern <code>age %R% unit</code>.</li>
```{r,warning=F,message=F}
# Test pattern with age then units
str_view(narratives, pattern = age %R% unit)
```
</div>
<div class="exercise--instructions__content">
<li>Create a <code>gender</code> pattern that matches an optional space then <code>M</code> or <code>F</code>.</li>
```{r,warning=F,message=F}
# Use these patterns
age <- DGT %R% optional(DGT)
unit <- optional(SPC) %R% or("YO", "YR", "MO")

# Pattern to match gender
gender <- optional(SPC) %R% or("M", "F")
```
<li>Check your pattern so far by using <code>str_view()</code> with the pattern <code>age %R% unit %R% gender</code>.</li>
```{r,warning=F,message=F}
# Test pattern with age then units then gender
str_view(narratives, pattern = age %R% unit %R% gender)
```
</div>
<div class="exercise--instructions__content"><p>Extract the age-unit-gender piece from each narrative using <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract"><code>str_extract()</code></a>.</p></div>
```{r,warning=F,message=F}
# Use these patterns
age <- DGT %R% optional(DGT)
unit <- optional(SPC) %R% or("YO", "YR", "MO")
gender <- optional(SPC) %R% or("M", "F")

# Extract age, unit, gender
str_extract(narratives,  age %R% unit %R% gender)
```

<p class="">Fantastic! You have the wisdom of a 99 YOF. You can also use <code>dgt(1, 2)</code> to match one or two digits.
</p>

##### Parsing age and gender into pieces {.unnumbered}


<div class>
<p>To finish up, you need to pull out the individual pieces and tidy them into usable variables.  </p>
<p>There are a few ways you could get at one piece: you could <strong>extract</strong> out the piece you need, you could <strong>replace</strong> everything that isn't the piece you need with <code>""</code>, or you could try to <strong>split</strong> into the pieces you need.  You'll try a few of these in this exercise and you'll see yet another way in the next chapter. For the first option, <code>stringr</code> has a nice convenience function, <a href="https://www.rdocumentation.org/packages/stringr/topics/str_remove"><code>str_remove()</code></a>, that works like <code>str_replace()</code> with <code>replacement = ""</code>.</p>
<p>One benefit of building up your pattern in pieces is you already have patterns for each part that you can reuse now.</p>
</div>
<div class="exercise--instructions__content"><p>Use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract"><code>str_extract</code></a> with your <code>age</code> pattern to extract just the age from <code>age_gender</code>, then transform it to a number with <a href="https://www.rdocumentation.org/packages/base/topics/numeric"><code>as.numeric()</code></a>.</p></div>
```{r,warning=F,message=F}
# age_gender, age, gender, unit are pre-defined
ls.str()

# Extract age_gender, take a look
age_gender <- str_extract(narratives, pattern = age %R% unit %R% gender)

# Extract age and make numeric
as.numeric(str_extract(age_gender, age))
```
<div class="exercise--instructions__content">
<li>Create <code>genders</code> by using <a href="https://www.rdocumentation.org/packages/stringr/topics/str_remove"><code>str_remove()</code></a> with your <code>age %R% unit</code> pattern to replace everything except the gender with <code>""</code>.</li>
<li>
```{r,warning=F,message=F}
# Replace age and units with ""
genders <- str_remove(age_gender, pattern = age %R% unit)
```
<code>genders</code> has a few extra spaces; remove them.</li>
```{r,warning=F,message=F}
# Replace extra spaces
str_remove_all(genders, pattern = one_or_more(SPC))
```
</div>
<div class="exercise--instructions__content">
<li>Get <code>time_units</code> by using <code>str_extract()</code> on <code>age_gender</code> with your <code>unit</code> pattern.</li>
```{r,warning=F,message=F}
# Numeric ages, from previous step
ages_numeric <- as.numeric(str_extract(age_gender, age))

# Extract units 
time_units <- str_extract(age_gender, unit)
```
<li>To know if the units are months or years we just need the first character after any spaces.  Use <code>str_extract()</code> on <code>time_units</code> with the pattern <code>WRD</code> to get <code>time_units_clean</code>. </li>
```{r,warning=F,message=F}
# Extract first word character
time_units_clean <- str_extract(time_units, WRD)
```
<li>Complete the final line to convert any ages reported in months to an age in years.</li>
```{r,warning=F,message=F}
# Turn ages in months to years
ifelse(time_units_clean == "Y", ages_numeric, ages_numeric / 12)
```
</div>

<p class="">Fantastic!  You can imagine this would be an important first step if you wanted to investigate the frequency of accidents by age or gender.  If you want a challenge, get the <code>neiss</code> package and see if you can extract age and gender from all <code>accidents</code>.
</p>

### Advanced manipulating {.unnumbered}

<p class="chapter__description">
    Now for two advanced ways to use regular expressions along with stringr: selecting parts of a match (a.k.a capturing) and referring back to parts of a match (a.k.a back-referencing).  You'll also learn to deal with and strings or patterns that contain Unicode characters (e.g. é).
  </p>
  
#### Capturing {.unnumbered}



##### Capturing parts of a pattern {.unnumbered}


<div class>
<p>In <code>rebus</code>, to denote a part of a regular expression you want to capture, you surround it with the function <code>capture()</code>. For example, a simple pattern to match an email address might be,</p>
<pre><code>email &lt;- one_or_more(WRD) %R% 
  "@" %R% one_or_more(WRD) %R% 
  DOT %R% one_or_more(WRD)
str_view("(<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="74031b180211061d1a11340c19111a5a171b19">[email protected]</a>)", pattern = email)  
</code></pre>
<p>If you want to capture the part before the <code>@</code>, you simply wrap that part of the regular expression in <code>capture()</code>:</p>
<pre><code>email &lt;- capture(one_or_more(WRD)) %R% 
  "@" %R% one_or_more(WRD) %R% 
  DOT %R% one_or_more(WRD)
str_view("(<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="394e56554f5c4b50575c7941545c57175a5654">[email protected]</a>)", pattern = email)  
</code></pre>
<p>The part of the string that matches hasn't changed, but if we pull out the match with <code>str_match()</code> we get access to the captured piece:</p>
<pre><code>str_match("(<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4631292a3023342f2823063e2b23286825292b">[email protected]</a>)", pattern =  email)  
</code></pre>
<p>You'll explore this behavior with some more super hero email addresses.</p>
</div>
<div class="exercise--instructions__content">
<li>Add some more <code>capture()</code> calls to the <code>email</code> pattern, to capture the part after the <code>@</code> but before the <code>.</code>; and the part after the <code>.</code>.</li>
```{r,warning=F,message=F}
# Capture parts between @ and . and after .
email <- capture(one_or_more(WRD)) %R% 
  "@" %R% capture(one_or_more(WRD)) %R% 
  DOT %R% capture(one_or_more(WRD))
```
<li>Check that the whole email address is matched by using <code>str_view()</code> on <code>hero_contacts</code> with the <code>email</code> pattern.</li>
```{r,warning=F,message=F}
hero_contacts <- c("(wolverine@xmen.com)", "wonderwoman@justiceleague.org", "thor@avengers.com")
# Check match hasn't changed
str_view(hero_contacts, email)
```
</div>

<div class="exercise--instructions__content">
<li>Use <code>str_match()</code> to pull out the match and capture the <code>email</code> pattern in <code>hero_contacts</code>, and print it to confirm all parts are captured.</li>
```{r,warning=F,message=F}
# Pattern from previous step
email <- capture(one_or_more(WRD)) %R% 
  "@" %R% capture(one_or_more(WRD)) %R% 
  DOT %R% capture(one_or_more(WRD))
  
# Pull out match and captures
email_parts <- str_match(hero_contacts, email)  
email_parts  
```
<li>Assign the third column of <code>email_parts</code> to <code>host</code> and print it.</li>
```{r,warning=F,message=F}
# Save host
host <- email_parts[, 3]
host
```
</div>

<p class="">Actually, detecting an email address can be really hard. See <a href="http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address/201378#201378" target="_blank" rel="noopener noreferrer">this discussion</a> for more details.
</p>

##### Pulling out parts of a phone number {.unnumbered}


<div class>
<p>You can now go back to the phone number example from the previous chapter. You developed a pattern to extract the parts of string that looked like phone numbers, and now you have the skills to pull out the pieces of the number.  Let's see if you can put your skills together to output the first phone number in each string in a common format.</p>
</div>
<div class="exercise--instructions__content">
<p>We've put the pieces of your pattern in your workspace, along with some text containing phone numbers in the variable <code>contact</code>.</p>

<li>
<code>phone_pattern</code> is the pattern you developed in the last chapter. Edit it to <code>capture()</code> each sequence of numbers.</li>
```{r,warning=F,message=F}
# View text containing phone numbers
contact

# Add capture() to get digit parts
phone_pattern <- capture(three_digits) %R% zero_or_more(separator) %R% 
           capture(three_digits) %R% zero_or_more(separator) %R%
           capture(four_digits)
```
<li>Use <code>str_match()</code> to grab all the pieces into <code>phone_numbers</code>.</li>
```{r,warning=F,message=F}
# Pull out the parts with str_match()
phone_numbers <- str_match(contact, phone_pattern)
```
<li>Put together the pieces with <code>str_c()</code> into the format <code>(XXX) XXX-XXXX</code>.</li>
```{r,warning=F,message=F}
# Put them back together
str_c(
  "(",  
  phone_numbers[, 2], 
  ") ", 
  phone_numbers[, 3], 
  "-", 
  phone_numbers[, 4])
```
</div>

<p class="">Great job! If you wanted to extract beyond the first phone number, e.g. The second phone number in the last string, you could use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_match_all" target="_blank" rel="noopener noreferrer"><code>str_match_all()</code></a>.  But, like <code>str_split()</code> it will return a list with one component for each input string, and you'll need to use <code>lapply()</code> to handle the result.
</p>

##### Extracting age and gender again {.unnumbered}


<div class><p>You can now also take another look at your pattern for pulling out age and gender from the injury narratives.  In the last chapter you took two steps to extract the pattern and then pull it apart.  Take a go at doing it in one step!</p></div>
<div class="exercise--instructions__content">
<p>We've written out your whole pattern here rather than use the pattern variables you created, because you'll need to capture pieces that were inside those patterns.</p>

<li>Add <code>capture()</code> to your pattern to pull out the <code>age</code>, <code>unit</code> and <code>gender</code> parts of the pattern.</li>
```{r,warning=F,message=F}
# narratives has been pre-defined
narratives

# Add capture() to get age, unit and sex
pattern <- capture(optional(DGT) %R% DGT) %R%  
  optional(SPC) %R% capture(or("YO", "YR", "MO")) %R%
  optional(SPC) %R% capture(or("M", "F"))
```
<li>Use <code>str_match()</code> to pull them out of <code>narratives</code>, and take a look.</li>
```{r,warning=F,message=F}
# Pull out from narratives
str_match(narratives, pattern)
```
</div>

<div class="exercise--instructions__content">
<li>That's pretty good, but it might be nice just to capture the first letter of the units, e.g. the <code>Y</code> or <code>M</code>.  Alter your pattern to capture a <code>Y</code> or <code>M</code>, and then <em><code>optional()</code>ly</em> match  <code>O</code> or <code>R</code>.  </li>
```{r,warning=F,message=F}
# Edit to capture just Y and M in units
pattern2 <- capture(optional(DGT) %R% DGT) %R%  
  optional(SPC) %R% capture(or("Y", "M")) %R% optional(or("O","R")) %R%
  optional(SPC) %R% capture(or("M", "F"))
```
<li>Check your new pattern still picks out the right pieces with <code>str_view()</code>.</li>
```{r,warning=F,message=F}
# Check pattern
str_view(narratives, pattern2)
```
<li>Pull out the pieces with <code>str_match()</code>.</li>
```{r,warning=F,message=F}
# Pull out pieces
str_match(narratives, pattern2)
```
</div>

<p class="">Courageous capturing! The combination of <code>capture()</code> and <code>str_match()</code> is powerful for extracting pieces of text.
</p>

#### Backreferences {.unnumbered}



##### Using backreferences in patterns {.unnumbered}


<div class>
<p>Backreferences can be useful in matching because they allow you to find repeated patterns or words.  Using a backreference requires two things:  you need to <a href="https://www.rdocumentation.org/packages/rebus.base/topics/capture"><code>capture()</code></a> the part of the pattern you want to reference, and then you refer to it with <a href="https://www.rdocumentation.org/packages/rebus.base/topics/Backreferences"><code>REF1</code></a>.  </p>
<p>Take a look at this pattern: <code>capture(LOWER) %R% REF1</code>. It matches and captures any lower case character, then is followed by the captured character: it detects repeated characters regardless of what character is repeated. To see it in action try this:</p>
<pre><code>str_view(c("hello", "sweet", "kitten"), 
  pattern = capture(LOWER) %R% REF1)
</code></pre>
<p>If you capture more than one thing you can refer to them with <code>REF2</code>, <code>REF3</code> etc. up to <code>REF9</code>, counting the captures from the left of the pattern.</p>
<p>Let's practice with <code>boy_names</code> again. You might notice a change in this dataset. We've converted all names to lower case; you'll learn how to do that in the next chapter.</p>
</div>

<div class="exercise--instructions__content">
<p>In each case, assign the pattern argument, then view the matches by running the <code>str_view()</code> code.</p>
<p>See all the <code>boy_names</code> with a letter repeated three times, by extending the pattern in the text above with another <code>REF1</code>. Assign the pattern to <code>repeated_three_times</code>.</p>
</div>
```{r,warning=F,message=F}
# Names with three repeated letters
repeated_three_times <- capture(LOWER) %R% REF1 %R% REF1

# Test it
str_view(boy_names, pattern = repeated_three_times, match = TRUE)
```
<div class="exercise--instructions__content"><p>See all the <code>boy_names</code> with a pair of letters repeated twice, e.g. <code>abab</code>, by capturing two lower case characters, then referring to the capture with <code>REF1</code>. Assign the pattern to <code>pair_of_repeated</code>.</p></div>
```{r,warning=F,message=F}
# Names with a pair of repeated letters
pair_of_repeated <- capture(LOWER %R% LOWER) %R% REF1

# Test it
str_view(boy_names, pattern = pair_of_repeated, match = TRUE)
```
<div class="exercise--instructions__content"><p>See all the <code>boy_names</code> with a pair of letter followed by their reverse, e.g. <code>abba</code>, by capturing two lower case characters separately and combining with <code>REF2</code> and <code>REF1</code>. Assign the pattern to <code>pair_that_reverses</code>.</p></div>
```{r,warning=F,message=F}
# Names with a pair that reverses
pair_that_reverses <- capture(LOWER) %R% capture(LOWER) %R% REF2 %R% REF1

# Test it
str_view(boy_names, pattern = pair_that_reverses, match = TRUE)
```
<div class="exercise--instructions__content"><p>See all the <code>boy_names</code> that are a four letter palindrome (a name that reads the same forwards and backwards) by wrappping the previous pattern in <a href="https://www.rdocumentation.org/packages/rebus.base/topics/exactly"><code>exactly()</code></a>. Assign the pattern to <code>four_letter_palindrome</code>.</p></div>
```{r,warning=F,message=F}
# Four letter palindrome names
four_letter_palindrome <- exactly(
  capture(LOWER) %R% capture(LOWER) %R% REF2 %R% REF1
)

# Test it
str_view(boy_names, pattern = four_letter_palindrome, match = TRUE)
```

<p class="">Badass backreferencing! In addition to matching repeated values, backreferences can also be used for replacement.
</p>

##### Replacing with regular expressions {.unnumbered}


<div class>
<p>Now, you've mastered matching with backreferences, you'll build up to replacing with backreferences, but first let's review <code>str_replace()</code> now that you've got regular expressions under your belt.</p>
<p>Remember <code>str_replace()</code> takes three arguments, <code>string</code> a vector of strings to do the replacements in, <code>pattern</code> that identifies the parts of strings to replace and <code>replacement</code> the thing to use as a replacement.</p>
<p><code>replacement</code> can be a vector, the same length as <code>string</code>, each element specifies the replacement to be used in each string.  Let's practice by anonymizing some of the contact objects you've seen so far.</p>
</div>
<div class="exercise--instructions__content">
<p>Text containing phone numbers has been pre-defined in a variable named <code>contact</code>.</p>
```{r,warning=F,message=F}
# View text containing phone numbers
contact
```

<li>Replace a digit in <code>contact</code> with <code>"X"</code> using <code>str_replace()</code>.</li>
```{r,warning=F,message=F}
# Replace digits with "X"
str_replace(contact, DGT, "X")
```
<li>Replace all digits in <code>contact</code> with <code>"X"</code> using <code>str_replace_all()</code>. (<code>str_replace()</code> will only replace the first match to the <code>pattern</code>. <code>str_replace_all()</code> will replace all matches to the pattern.)</li>
```{r,warning=F,message=F}
# Replace all digits with "X"
str_replace_all(contact, DGT, "X")
```
<li>Replace all digits in <code>contact</code> using <code>str_replace_all()</code>, but now specify the vector <code>c("X", ".", "*", "_")</code> as <code>replacement</code>.  <em>Notice how now each string uses a different replacement character.</em>
</li>
```{r,warning=F,message=F}
# Replace all digits with different symbol
str_replace_all(contact, DGT, c("X", ".", "*", "_"))
```
</div>

<p class="">You're irreplaceable! Using <code>""</code> for the replacement value is a great way to cut unwanted bits from a string.
</p>

#### Replacing with backreferences {.unnumbered}


<div class>
<p>The <code>replacement</code> argument to <code>str_replace()</code> can also include backreferences.  This works just like specifying patterns with backreferences, except the capture happens in the <code>pattern</code> argument, and the backreference is used in the <code>replacement</code> argument.</p>
<pre><code>x &lt;- c("hello", "sweet", "kitten")
str_replace(x, capture(ANY_CHAR), str_c(REF1, REF1))
</code></pre>
<p><code>capture(ANY_CHAR)</code> will match the first character no matter what it is. Then the replacement <code>str_c(REF1, REF1)</code> combines the captured character with itself, in effect doubling the first letter of each string.</p>
<p>You are going to use this to create some alternative, more lively accident narratives.</p>
<p>The strategy you'll take is to match words ending in <code>"ING"</code> then replace them with an adverb followed by the original word.</p>
</div>
<div class="exercise--instructions__content">
<li>Build a pattern that finds words that end in <code>"ING"</code>.  You'll want to check it against <code>narratives</code> using <code>str_view()</code>.</li>
```{r,warning=F,message=F}
# Build pattern to match words ending in "ING"
pattern <- one_or_more(WRD) %R% "ING"
str_view(narratives, pattern)
```
<li>Test out the replacement by using <code>str_replace()</code> with your pattern (don't forget to <code>capture()</code> it!) and a replacement <code>str_c("CARELESSLY", REF1, sep = " ")</code>.</li>
```{r,warning=F,message=F}
# Test replacement
str_replace(narratives, capture(pattern), 
  str_c("CARELESSLY", REF1, sep = " "))
```
<li>Build a vector with one adverb for each narrative by sampling 10 elements from <code>adverbs</code>. </li>
```{r,warning=F,message=F}
adverbs <- readRDS("archive/String-Manipulation-with-stringr-in-R/adverbs.rds")
# One adverb per narrative
adverbs_10 <- sample(adverbs, 10)
```
<li>Do the final replacement by using <code>str_c(adverbs_10, REF1, sep = " ")</code>.</li>
```{r,warning=F,message=F}
# Replace "***ing" with "adverb ***ly"
str_replace(narratives, 
  capture(pattern),
  str_c(adverbs_10, REF1, sep = " "))  
```
</div>

<p class="">Be careful. Your code is so sharp you might cut something! Replacement combined with backreferences can be really useful for reformatting text data.
</p>

#### Unicode and pattern matching {.unnumbered}



##### Matching a specific code point or code groups {.unnumbered}


<div class>
<p>Things can get tricky when some characters can be specified two ways, for example è, an e with a grave accent, can be specified either with the single code point <code>\\u00e8</code> or the combination of a <code>\\u0065</code> and a combining grave accent <code>\\u0300</code>. They look the same:</p>
<pre><code>x &lt;- c("\\u00e8", "\\u0065\\u0300")
writeLines(x)
</code></pre>
<p>But, specifying the single code point only matches that version:</p>
<pre><code>str_view(x, "\\u00e8")
</code></pre>
<p>The <code>stringi</code> package that <code>stringr</code> is built on contains functions for converting between the two forms. <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_trans_nfc"><code>stri_trans_nfc()</code></a> composes characters with combining accents into a single character. <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_trans_nfc"><code>stri_trans_nfd()</code></a> decomposes character with accents into separate letter and accent characters. You can see how the characters differ by looking at the hexadecimal codes.</p>
```{r,warning=F,message=F}
library(stringi)
```
<pre><code>as.hexmode(utf8ToInt(stri_trans_nfd("\\u00e8")))
as.hexmode(utf8ToInt(stri_trans_nfc("\\u0065\\u0300")))
</code></pre>
<p>In Unicode, an accent is known as a <em>diacritic Unicode Property</em>, and you can match it using the <code>rebus</code> value <code>UP_DIACRITIC</code>.</p>
<p>Vietnamese makes heavy use of diacritics to denote the tones in its words. In this exercise, you'll manipulate the diacritics in the names of Vietnamese rulers.</p>
</div>
<div class="exercise--instructions__content">
<p>Names of rulers from the 18th Century Vietnamese Tây Sơn dynasty are shown in the script.</p>

<li>
<code>tay_son_builtin</code> has the accents built into each letter. Run the code that defines and prints this variable.</li>
```{r,warning=F,message=F}
# Names with builtin accents
tay_son_builtin <- c(
  "Nguy\u1ec5n Nh\u1ea1c", 
  "Nguy\u1ec5n Hu\u1ec7",
  "Nguy\u1ec5n Quang To\u1ea3n"
)
```
<li>Call <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_trans_nfc"><code>stri_trans_nfd()</code></a> to decompose the letters with accents into separate letter and accent characters, and assign the result to <code>tay_son_separate</code>.</li>
```{r,warning=F,message=F}
# Convert to separate accents
tay_son_separate <- stri_trans_nfd(tay_son_builtin)
```
<li>Print <code>tay_son_separate</code> to verify the names still display the same way.</li>
```{r,warning=F,message=F}
#Verify that the string prints the same
tay_son_separate
```
<li>View all the accents by calling <code>str_view_all()</code> and matching <code>UP_DIACRITIC</code>. The match is shown after the letter that the diacritic belongs to.</li>
```{r,warning=F,message=F}
# Match all accents
str_view_all(tay_son_separate, UP_DIACRITIC)
```
</div>

<p class="">Xin chúc mừng! 'It is useful to be consistent about combining or separating diacritics.' - possibly a Vietnamese proverb.
</p>

##### Matching a single grapheme {.unnumbered}


<div class>
<p>A related problem is matching a single character.  You've used <code>ANY_CHAR</code> to do this up until now, but it will only match a character represented by a single code point.  Take these three names:</p>
<pre><code>x &lt;- c("Adele", "Ad\\u00e8le", "Ad\\u0065\\u0300le")
writeLines(x)
</code></pre>
<p>They look the similar, but this regular expression only matches two of them:</p>
<pre><code>str_view(x, "Ad" %R% ANY_CHAR %R% "le")
</code></pre>
<p>because in the third name è is represented by two code points.  The Unicode standard has a concept of a <em>grapheme</em> that represents a display character, but may be composed of many code points.  To match any <em>grapheme</em> you can use <code>GRAPHEME</code>.</p>
<pre><code>str_view(x, "Ad" %R% GRAPHEME %R% "le")
</code></pre>
<p>Names of rulers from the Vietnamese Tây Sơn dynasty, with diacritics given as separate graphemes, is pre-defined as <code>tay_son_separate</code>.</p>
</div>
```{r,warning=F,message=F}
# tay_son_separate has been pre-defined
tay_son_separate
```
<div class="exercise--instructions__content"><p>Use <code>str_view_all()</code>, with <code>ANY_CHAR</code> as a pattern to view each character in <code>tay_son_separate</code>.</p></div>
```{r,warning=F,message=F}
# View all the characters in tay_son_separate
str_view_all(tay_son_separate, ANY_CHAR)
```
<div class="exercise--instructions__content"><p>Do the same again with <code>GRAPHEME</code> as a pattern, to see the difference between characters and graphemes.</p></div>
```{r,warning=F,message=F}
# View all the graphemes in tay_son_separate
str_view_all(tay_son_separate, GRAPHEME)
```
<div class="exercise--instructions__content">
<li>Use <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_trans_nfc"><code>stri_trans_nfc()</code></a> to combine the diacritics with their associated characters, storing the result as <code>tay_son_builtin</code>.</li>
```{r,warning=F,message=F}
# Combine the diacritics with their letters
tay_son_builtin <- stri_trans_nfc(tay_son_separate)
tay_son_builtin
```
<li>Use <code>str_view_all()</code> to view each grapheme in <code>tay_son_builtin</code>.</li>
```{r,warning=F,message=F}
# View all the graphemes in tay_son_builtin
str_view_all(tay_son_builtin, GRAPHEME)
```
</div>

<p class="">Graceful grapheme work! Now back to some English text for the final chapter.
</p>

### Case studies {.unnumbered}

<p class="chapter__description">
    Practice your string manipulation skills on a couple of case studies.  You'll also learn a few new skills, reading strings into R and handling problems of case (e.g. A versus a).
  </p>
  
#### Case study {.unnumbered}



##### Getting the play into R {.unnumbered}


<div class>
<p>We've already downloaded the play and put the text file in your workspace.  Your first step is to read the play into R using <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_read_lines"><code>stri_read_lines()</code></a>.  </p>
<p>You should take a look at the original text file: <a href="http://s3.amazonaws.com/assets.datacamp.com/production/course_2922/datasets/importance-of-being-earnest.txt">importance-of-being-earnest.txt</a></p>
<p>You'll see there is some foreword and afterword text that Project Gutenberg has added. You'll want to remove that, and then split the play into the introduction (the list of characters, scenes, etc.) and the main body.</p>
</div>

<div class="exercise--instructions__content"><p>Use <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_read_lines"><code>stri_read_lines()</code></a> to read the play from <code>earnest_file</code> into <code>earnest</code>.</p></div>
```{r,warning=F,message=F}
earnest <- stri_read_lines("https://assets.datacamp.com/production/repositories/755/datasets/3de2fac5679f5b2653ec1e23d0268152ab201b4a/importance-of-being-earnest.txt")

```
<div class="exercise--instructions__content">
<li>Find the lines that end the foreword and start of afterword by detecting the patterns <code>"START OF THE PROJECT"</code> and <code>"END OF THE PROJECT"</code>.</li>
```{r,warning=F,message=F}
# Detect start and end lines
start <- str_which(earnest, fixed("START OF THE PROJECT"))
end <- str_which(earnest, fixed("END OF THE PROJECT"))
```
<li>Use the <code>start</code> and <code>end</code> positions to subset the play to the lines between <code>(start + 1)</code> and <code>(end - 1)</code>.</li>
```{r,warning=F,message=F}
# Get rid of gutenberg intro text
earnest_sub  <- earnest[(start + 1):(end - 1)]
```
</div>

<div class="exercise--instructions__content">
<li>Find the lines which start the first act by looking for the pattern <code>"FIRST ACT"</code>.</li>
```{r,warning=F,message=F}
# Detect first act
lines_start <- str_which(earnest_sub, fixed("FIRST ACT"))
```
<li>Build an index that captures the <code>intro_line_index</code> with <code>1:(lines_start - 1)</code>.</li>
```{r,warning=F,message=F}
# Set up index
intro_line_index <- 1:(lines_start - 1)
```
<li>Use <code>intro_line_index</code> to extract the intro text and <code>-intro_line_index</code> to extract the play text.</li>
```{r,warning=F,message=F}
# Split play into intro and play
intro_text <- earnest_sub[intro_line_index]
play_text <- earnest_sub[-intro_line_index]
```
</div>
<div class="exercise--instructions__content"><p>Look at the first twenty lines using <code>writeLines()</code> on a subset of <code>play_text</code>.</p></div>
```{r,warning=F,message=F}
# Take a look at the first 20 lines
writeLines(play_text[1:20])
```

<p class="">You clearly understand the importance of being awesome! <code>stri_read_lines()</code> is a high performance alternative to <code>readLines()</code>.
</p>

##### Identifying the lines, take 1 {.unnumbered}

<div class>
<p>The first thing you might notice when you look at your vector <code>play_text</code> is there are lots of empty lines. They don't really affect your task so you might want to remove them. The easiest way to find empty strings is to use the <code>stringi</code> function <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_isempty"><code>stri_isempty()</code></a>, which returns a logical you can use to subset the not-empty strings:</p>
<pre><code># Get rid of empty strings
empty &lt;- stri_isempty(play_text)
play_lines &lt;- play_text[!empty]
</code></pre>
<p>So, how are you going to find the elements that indicate a character starts their line? Consider the following lines</p>
<pre><code>&gt; play_lines[10:15]
[1] "Algernon.  I'm sorry for that, for your sake.  I don't play"             
[2] "accurately--any one can play accurately--but I play with wonderful"      
[3] "expression.  As far as the piano is concerned, sentiment is my forte.  I"
[4] "keep science for Life."                                                  
[5] "Lane.  Yes, sir."                                                        
[6] "Algernon.  And, speaking of the science of Life, have you got the"
</code></pre>
<p>The first line is for <code>Algernon</code>, the next three strings are continuations of that line, then line 5 is for <code>Lane</code> and line <code>6</code> for <code>Algernon</code>.  </p>
<p>How about looking for lines that start with a word followed by a <code>.</code>?</p>
<p><code>play_lines</code>, containing the lines of the play as a character vector, has been pre-defined.</p>
</div>
<div class="exercise--instructions__content">
<li>Build a pattern that matches the start of the line, followed by one or more word characters, then a period.</li>
```{r,warning=F,message=F}
# Pattern for start, word then .
pattern_1 <- START %R% one_or_more(WRD) %R% DOT
```
<li>Use your pattern with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_view"><code>str_view()</code></a> to see the lines that matched, and those that didn't match.  <em>Do you see any problems?</em>
</li>
```{r,warning=F,message=F}
# Get rid of empty strings
empty <- stri_isempty(play_text)
play_lines <- play_text[!empty]
# Test pattern_1
str_view(play_lines, pattern_1, match = TRUE) 
str_view(play_lines, pattern_1, match = FALSE)
```
</div>

<div class="exercise--instructions__content">
<li>Try a more specific pattern: the start of the line, a capital letter, followed by one or more word characters, then a full stop.</li>
```{r,warning=F,message=F}
# Pattern for start, capital, word then .
pattern_2 <- START %R% ascii_upper() %R% one_or_more(WRD) %R% DOT
```
<li>As before, view the matched lines, by calling <code>str_view()</code> with <code>match = TRUE</code> and <code>match = FALSE</code>.</li>
```{r,warning=F,message=F}
# Test pattern_2
str_view(play_lines, pattern_2, match = TRUE)
str_view(play_lines, pattern_2, match = FALSE)
```
</div>

<div class="exercise--instructions__content">
<li>Use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset" target="_blank" rel="noopener noreferrer"><code>str_subset()</code></a> to get just the lines that match our pattern.</li>
```{r,warning=F,message=F}
# Pattern from last step
pattern_2 <- START %R% ascii_upper() %R% one_or_more(WRD) %R% DOT

# Get subset of lines that match
lines <- str_subset(play_lines, pattern_2)
```
<li>Use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract" target="_blank" rel="noopener noreferrer"><code>str_extract()</code></a> to get the part of the string that matched our pattern in <code>lines</code> .</li>
```{r,warning=F,message=F}
# Extract match from lines
who <- str_extract(lines, pattern_2)
```
<li>Use <a href="https://www.rdocumentation.org/packages/base/topics/unique" target="_blank" rel="noopener noreferrer"><code>unique()</code></a> on <code>who</code> to see if we picked out the characters.</li>
```{r,warning=F,message=F}
# Let's see what we have
unique(who)
```
</div>

<p class="">Good job, but it looks like your pattern wasn't 100% successful. It missed Lady Bracknell, and picked up lines starting with <code>University.</code>, <code>July.</code> and a few others.  Let's try a slightly different strategy.
</p>

##### Identifying the lines, take 2 {.unnumbered}


<div class>
<p>The pattern "starts with a capital letter, has some other characters then a full stop" wasn't specific enough.  You ended up matching lines that started with things like  <code>University.</code>,  <code>July.</code>, <code>London.</code>, and you missed characters like <code>Lady Bracknell</code> and  <code>Miss Prism</code>.</p>
<p>Let's take a different approach.  You know the characters names from the play introduction.  So, try specifically looking for lines that start with their names.  You'll find the <a href="https://www.rdocumentation.org/packages/rebus/versions/0.0-4/topics/or"><code>or1()</code></a> function from the <code>rebus</code> package helpful. It specifies alternatives but rather than each alternative being an argument like in <code>or()</code>, you can pass in a vector of alternatives.</p>
<p>We've created the <code>characters</code> vector for you with all the characters names.</p>
```{r,warning=F,message=F}
# Create vector of characters
characters <- c("Algernon", "Jack", "Lane", "Cecily", "Gwendolen", "Chasuble", 
  "Merriman", "Lady Bracknell", "Miss Prism")
```
</div>
<div class="exercise--instructions__content">
<li>Create a pattern that matches the start of the string, followed by one of the characters names using <a href="https://www.rdocumentation.org/packages/rebus/versions/0.0-4/topics/or"><code>or1()</code></a>, followed by a <code>.</code>.</li>
```{r,warning=F,message=F}
# Match start, then character names then .
pattern_3 <- START %R% or1(characters) %R% DOT
```
<li>Test your pattern. <ul>
<li>View matches of <code>pattern_3</code> on the <code>play_lines</code> character vector.</li>
<li>View non-matches of the same.</li>
<li><em>Does it look like it worked?</em></li>
</ul>
</li>
```{r,warning=F,message=F}
# Match start, then character names then .
pattern_3 <- START %R% or1(characters) %R% DOT

# View matches of pattern_3
str_view(play_lines, pattern_3, match = TRUE) 

# View non-matches of pattern_3
str_view(play_lines, pattern_3, match = FALSE)
```
</div>

<div class="exercise--instructions__content">
<li>Pull out the lines that match with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset" target="_blank" rel="noopener noreferrer"><code>str_subset()</code></a>.</li>
```{r,warning=F,message=F}
# Pull out matches
lines <- str_subset(play_lines, pattern_3)

```
<li>Pull out the parts that matched with <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract" target="_blank" rel="noopener noreferrer"><code>str_extract()</code></a>.</li>
```{r,warning=F,message=F}
# Extract match from lines
who <- str_extract(lines, pattern_3)
```
<li>Take a look at the <a href="https://www.rdocumentation.org/packages/base/topics/unique" target="_blank" rel="noopener noreferrer"><code>unique()</code></a> characters you found. </li>
```{r,warning=F,message=F}
# Let's see what we have
unique(who)
```
<li>Finally, tally up how many lines each character had, but using <a href="https://www.rdocumentation.org/packages/base/topics/table" target="_blank" rel="noopener noreferrer"><code>table()</code></a> on <code>who</code>.</li>
```{r,warning=F,message=F}
# Count lines per character
table(who)
```
</div>

<p class="">You did it! Algernon and Jack get the most lines, more than ten times more than Merriman who has the fewest.  If you were looking really closely you might have noticed the pattern didn't pick up the line <code>Jack and Algernon [Speaking together.]</code> which you really should be counting as a line for both Jack and Algernon. One solution might be to look for these <code>"Speaking together"</code> lines, parse out the characters, and add to your counts.
</p>

#### A case study on case {.unnumbered}

##### Changing case to ease matching {.unnumbered}


<div class>
<p>A simple solution to working with strings in mixed case, is to simply transform them into all lower or all upper case. Depending on your choice, you can then specify your pattern in the same case.</p>
<p>For example, while looking for <code>"cat"</code> finds no matches in the following string,</p>
<pre><code>x &lt;- c("Cat", "CAT", "cAt") 
str_view(x, "cat")
</code></pre>
<p>transforming the string to lower case first ensures all variations match.</p>
<pre><code>str_view(str_to_lower(x), "cat")
</code></pre>
<p>See if you can find the catcidents that also involved dogs.  You'll see a new <code>rebus</code> function called <a href="https://www.rdocumentation.org/packages/rebus.base/topics/WordBoundaries"><code>whole_word()</code></a>. The argument to <code>whole_word()</code> will only match if it occurs as a word on its own, for example <code>whole_word("cat")</code> will match <code>cat</code> in <code>"The cat "</code> and <code>"cat."</code> but not in <code>"caterpillar"</code>.</p>
<p>A character vector of cat-related accidents has been pre-defined in your workspace as <code>catcidents</code>.</p>
```{r,warning=F,message=F}
catcidents <- readRDS("archive/String-Manipulation-with-stringr-in-R/catcidents.rds")

# catcidents has been pre-defined
head(catcidents)
```
</div>
<div class="exercise--instructions__content">
<li>Create a pattern to match <code>"DOG"</code> as a whole word using <a href="https://www.rdocumentation.org/packages/rebus.base/topics/WordBoundaries"><code>whole_word()</code></a>, assigning the result to <code>whole_dog_pattern</code>.</li>
```{r,warning=F,message=F}
# Construct pattern of DOG in boundaries
whole_dog_pattern <- whole_word("DOG")
```
<li>View the matches to <code>whole_dog_pattern</code> in the original mixed case <code>catcidents</code>.</li>
```{r,warning=F,message=F}
# See matches to word DOG
str_view(catcidents, pattern = whole_dog_pattern, match = TRUE)
```
</div>

<div class="exercise--instructions__content">
<li>Create <code>catcidents_upper</code> by transforming all the strings in <code>catcidents</code> to upper case.  </li>
```{r,warning=F,message=F}
# Transform catcidents to upper case
catcidents_upper <- str_to_upper(catcidents)
```
<li>Take another look at the matches to <code>whole_dog_pattern</code>, this time using <code>catcidents_upper</code> as the input.</li>
```{r,warning=F,message=F}
# View matches to word "DOG" again
str_view(catcidents_upper, pattern = whole_dog_pattern, match = TRUE)
```
</div>

<div class="exercise--instructions__content"><p>If you need to retain the original mixed case strings, you can use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_detect" target="_blank" rel="noopener noreferrer"><code>str_detect()</code></a> on the transformed strings to subset the original strings. </p>
<li>Try it by creating <code>has_dog</code> from calling <code>str_detect()</code> on <code>catcidents_upper</code> with the upper case pattern.</li>
```{r,warning=F,message=F}
# Which strings match?
has_dog <- str_detect(catcidents_upper, 
  pattern = whole_dog_pattern)
```
<li>Use <code>has_dog</code> and square brackets to subset <code>catcidents</code>.</li>
```{r,warning=F,message=F}
# Pull out matching strings in original 
catcidents[has_dog]
```
</div>

<p class="">Nice work! Seems like some of those catcidents might not have been the cat's fault.
</p>

##### Ignoring case when matching {.unnumbered}


<div class>
<p>Rather than transforming the input strings, another approach is to specify that the matching should be case insensitive.  This is one of the options to the <code>stringr</code> <a href="https://www.rdocumentation.org/packages/stringr/topics/modifiers"><code>regex()</code></a> function.  </p>
<p>Take our previous example,</p>
<pre><code>x &lt;- c("Cat", "CAT", "cAt") 
str_view(x, "cat")
</code></pre>
<p>To match the pattern <code>cat</code> in a case insensitive way, we wrap our pattern in <code>regex()</code> and specify the argument <code>ignore_case = TRUE</code>, </p>
<pre><code>str_view(x, regex("cat", ignore_case = TRUE))
</code></pre>
<p>Notice that the matches retain their original case and any variant of <code>cat</code> matches.</p>
<p>Try it out to find the catcidents that involved tripping.</p>
</div>
<div class="exercise--instructions__content">
<li>First view the matches of <code>catcidents</code> to the pattern <code>"TRIP"</code>.  <em>Notice how you only match those that are <code>TRIP</code> all in upper case.</em>
</li>
```{r,warning=F,message=F}
# View matches to "TRIP"
str_view(catcidents, pattern = "TRIP", match = TRUE)
```
<li>Construct a case-insensitive regex to <code>"TRIP"</code> by calling <a href="https://www.rdocumentation.org/packages/stringr/topics/modifiers"><code>regex()</code></a> with <code>ignore_case = TRUE</code>. Assign the result to <code>trip_pattern</code>.</li>
```{r,warning=F,message=F}
# Construct case insensitive pattern
trip_pattern <- regex("TRIP", ignore_case = TRUE)
```
<li>Repeat your viewing of catcident trips, this time using the case insensitive <code>trip_pattern</code>.  <em>You should get a few more hits.</em>
</li>
```{r,warning=F,message=F}
# View case insensitive matches to "TRIP"
str_view(catcidents, pattern = trip_pattern, match = TRUE)
```
</div>

<div class="exercise--instructions__content">
<li>Extract only the catcidents that matched <code>trip_pattern</code> by using <a href="https://www.rdocumentation.org/packages/stringr/topics/str_subset" target="_blank" rel="noopener noreferrer"><code>str_subset()</code></a>. Assign the result to <code>trip</code>.</li>
```{r,warning=F,message=F}
# Get subset of matches
trip <- str_subset(catcidents, pattern = trip_pattern)
```
<li>Use <a href="https://www.rdocumentation.org/packages/stringr/topics/str_extract" target="_blank" rel="noopener noreferrer"><code>str_extract()</code></a> on <code>trip</code> with <code>trip_pattern</code> to pull out the matching parts.</li>
```{r,warning=F,message=F}
# Extract matches
str_extract(trip, pattern = trip_pattern)
```
</div>

<p class="">Incredible use of case insensitivity!
</p>

##### Fixing case problems {.unnumbered}


<div class>
<p>Finally, you might want to transform strings to a common case.  You've seen you can use <code>str_to_upper()</code> and <code>str_to_lower()</code>, but there is also <a href="https://www.rdocumentation.org/packages/stringr/topics/case"><code>str_to_title()</code></a> which transforms to title case, in which every word starts with a capital letter.</p>
<p>This is another situation where <code>stringi</code> functions offer slightly more functionality than the <code>stringr</code> functions.</p>
```{r,warning=F,message=F}
library(stringi)
```
<p>The <code>stringi</code> function <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_trans_totitle"><code>stri_trans_totitle()</code></a> allows a specification of the <code>type</code> which, by default, is <code>"word"</code>, resulting in title case, but can also be <code>"sentence"</code> to give sentence case: only the first word in each sentence is capitalized.</p>
<p>Try outputting the <code>catcidents</code> in a consistent case.</p>
</div>
<div class="exercise--instructions__content">
<p>A character vector of cat-related accidents has been pre-defined in your workspace as <code>catcidents</code>.</p>
<li>Store the first five elements of <code>catcidents</code> as <code>cat5</code>.</li>
```{r,warning=F,message=F}
# Get first five catcidents
cat5 <- catcidents[1:5]
```
<li>Use <code>writeLines()</code> to display <code>cat5</code>.</li>
```{r,warning=F,message=F}
# Take a look at original
writeLines(cat5)
```
<li>Repeat but now pass <code>cat5</code> transformed to title case with <a href="https://www.rdocumentation.org/packages/stringr/topics/case"><code>str_to_title()</code></a>.</li>
```{r,warning=F,message=F}
# Transform to title case
writeLines(str_to_title(cat5))
```
<li>Try again using <a href="https://www.rdocumentation.org/packages/stringi/topics/stri_trans_totitle"><code>stri_trans_totitle()</code></a> instead.  <em>This should be identical to <code>str_to_title()</code></em>.</li>
```{r,warning=F,message=F}
# Transform to title case with stringi
writeLines(stri_trans_totitle(cat5))
```
<li>Finally, display the first 5 elements of <code>cat5</code> transformed to sentence case, by passing the <code>type</code> argument to <code>stri_trans_totitle()</code>.</li>
```{r,warning=F,message=F}
# Transform to sentence case with stringi
writeLines(stri_trans_totitle(cat5, 
  type = "sentence"))
```
</div>

#### Wrapping up {.unnumbered}

##### Wrapping up {.unnumbered}

You've moved from just entering strings in R, to putting strings together, detecting, extracting and splitting strings, describing patterns with regular expressions, and putting them together to capture, alter, and count interesting patterns in strings.

##### Next steps {.unnumbered}

You've learnt a lot of string manipulation functions from the stringr package, but now you might want to take a look at all the functions in stringr. We've covered those we think are most useful, but you might find some others that are particularly useful to you. Now you are now familiar with stringr syntax, you should find using any of the functions we didn't cover straightforward. Remember stringr is built on top of the stringi package, and stringi contains a much larger set of functions. If you do find something that stringr doesn't seem to help with, take a look at stringi first. You'll find using stringi feels very familiar, it borrows a lot of its API from stringr, for example, it uses a common prefix for all it's functions, and consistently expects a vector of strings as the first argument. I hope we've convinced you of the power of regular expressions. However, they can be notoriously difficult to get working sometimes. We hope you'll learn more about them. A great place to start is [FILL IN THE BLANK] or, if you are ready to dive deep, Mastering Regular Expressions by Jeffrey Friedl is a canonical text. If you are interested in seeing more regular expressions without using the rebus package, check out the section in R for Data Science: http://r4ds-dot-had-dot-co-dot-nz/strings-dot-html#matching-patterns-with-regular-expressions. If you've enjoyed working with strings,

##### Next steps {.unnumbered}

you might think about taking the "Text Mining: Bag of Words" course, which moves from just manipulating strings to analyzing them for insight. That's all I have for you.

##### Let's practice! {.unnumbered}

I've really enjoyed this course and I hope you have too. Stay tuned, for your final video. I'll be interviewing my brother Hadley Wickham an author of many R packages but in particular the creator of the stringr package.
