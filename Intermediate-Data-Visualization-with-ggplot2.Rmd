## Intermediate ggplot2 {.unnumbered}

<h3 class="course__description-title">Rick Scavetta</h3>
<p class="course__description">Rick Scavetta is a biologist, workshop trainer, freelance data scientist and cofounder of Scavetta Academy, a company dedicated to helping scientists better understand and visualize their data. Rick's practical, hands-on exposure to a wide variety of datasets has informed him of the many problems scientists face when trying to visualize their data.</p>

**Course Description**

<p class="course__description">This ggplot2 course builds on your knowledge from the introductory course to produce meaningful explanatory plots. Statistics will be calculated on the fly and you’ll see how Coordinates and Facets aid in communication. You’ll also explore details of data visualization best practices with ggplot2 to help make sure you have a sound understanding of what works and why. By the end of the course, you’ll have all the tools needed to make a custom plotting function to explore a large data set, combining statistics and excellent visuals.</p>

### Statistics {.unnumbered}

<p class="chapter__description">
    A picture paints a thousand words, which is why R ggplot2 is such a powerful tool for graphical data analysis. In this chapter, you’ll progress from simply plotting data to applying a variety of statistical methods. These include a variety of linear models, descriptive and inferential statistics (mean, standard deviation and confidence intervals) and custom functions.
  </p>

#### Stats with geoms {.unnumbered}



##### Smoothing {.unnumbered}


<div class>
<p>To practice on the remaining layers (statistics, coordinates and facets), we'll continue working on several datasets from the first course.</p>
<p>The <code>mtcars</code> dataset contains information for 32 cars from Motor Trends magazine from 1974. This dataset is small, intuitive, and contains a variety of continuous and categorical (both nominal and ordinal) variables.</p>
<p>In the previous course you learned how to effectively use some basic geometries, such as point, bar and line. In the first chapter of this course you'll explore statistics associated with specific geoms, for example, smoothing and lines.</p>
</div>


```{r}
# edited/added
library(tidyverse)
```
<li>Look at the structure of <code>mtcars</code>.</li>
<li>Using <code>mtcars</code>, draw a scatter plot of <code>mpg</code> vs. <code>wt</code>.</li>
```{r}
# View the structure of mtcars
str(mtcars)

# Using mtcars, draw a scatter plot of mpg vs. wt
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point()
```


<div class="exercise--instructions__content"><p>Update the plot to add a smooth trend line. Use the default method, which uses the LOESS model to fit the curve.</p></div>
```{r}
# Amend the plot to add a smooth layer
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  geom_smooth()
```

<div class="exercise--instructions__content"><p>Update the smooth layer. Apply a linear model by setting <code>method</code> to <code>"lm"</code>, and turn off the model's 95% confidence interval (the ribbon) by setting <code>se</code> to <code>FALSE</code>.</p></div>
```{r}
# Amend the plot. Use lin. reg. smoothing; turn off std err ribbon
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```

<div class="exercise--instructions__content"><p>Draw the same plot again, swapping <code>geom_smooth()</code> for <code>stat_smooth()</code>.</p></div>
```{r}
# Amend the plot. Swap geom_smooth() for stat_smooth().
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE)
```

<p class="">Good job! You can use either <a href="http://www.rdocumentation.org/packages/ggplot2/functions/geom_smooth" target="_blank" rel="noopener noreferrer"><code>stat_smooth()</code></a> or <a href="http://www.rdocumentation.org/packages/ggplot2/functions/geom_smooth" target="_blank" rel="noopener noreferrer"><code>geom_smooth()</code></a> to apply a linear model. Remember to always think about how the examples and concepts we discuss throughout the data viz courses can be applied to your own datasets!
</p>

##### Grouping variables {.unnumbered}


<div class>
<p>We'll continue with the previous exercise by considering the situation of looking at sub-groups in our dataset. For this we'll encounter the invisible <code>group</code> aesthetic.</p>
<p><code>mtcars</code> has been given an extra column, <code>fcyl</code>, that is the <code>cyl</code> column converted to a proper factor variable.</p>
</div>


```{r}
# edited/added
mtcars <- mtcars %>% 
  mutate(fcyl = as.factor(cyl),
         fam = as.factor(am))
```
<li>Using <code>mtcars</code>, plot <code>mpg</code> vs. <code>wt</code>, colored by <code>fcyl</code>.</li>
<li>Add a point layer.</li>
<li>Add a smooth stat using a linear model, and don't show the <code>se</code> ribbon.</li>
```{r}
# Using mtcars, plot mpg vs. wt, colored by fcyl
ggplot(mtcars, aes(x = wt, y = mpg, color = fcyl)) +
  # Add a point layer
  geom_point() +
  # Add a smooth lin. reg. stat, no ribbon
  stat_smooth(method = "lm", se = FALSE)
```





<li>Update the plot to add a second smooth stat.<ul>
<li>Add a dummy <code>group</code> aesthetic to this layer, setting the value to <code>1</code>.</li>
<li>Use the same <code>method</code> and <code>se</code> values as the first stat smooth layer.</li>
</ul>
</li>
```{r}
# Amend the plot to add another smooth layer with dummy grouping
ggplot(mtcars, aes(x = wt, y = mpg, color = fcyl)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE) +
  stat_smooth(aes(group = 1), method = "lm", se = FALSE)
```

<p class="">Good job! Notice that the color aesthetic defined an invisible group aesthetic. Defining the group aesthetic for a specific geom means we can overwrite that. Here, we use a dummy variable to calculate the smoothing model for all values.
</p>

##### Modifying stat_smooth {.unnumbered}


<div class><p>In the previous exercise we used <code>se = FALSE</code> in <code>stat_smooth()</code> to remove the 95% Confidence Interval. Here we'll consider another argument, <code>span</code>, used in LOESS smoothing, and we'll take a look at a nice scenario of properly mapping different models.</p></div>
<div class="exercise--instructions__content">
<p>Explore the effect of the <code>span</code> argument on LOESS curves. Add three smooth LOESS stats, each without the standard error ribbon.</p>
<ul>
<li>Color the 1st one <code>"red"</code>; set its <code>span</code> to <code>0.9</code>.</li>
<li>Color the 2nd one <code>"green"</code>; set its <code>span</code> to <code>0.6</code>.</li>
<li>Color the 3rd one <code>"blue"</code>; set its <code>span</code> to <code>0.3</code>.</li>
</ul>
</div>
```{r}
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  # Add 3 smooth LOESS stats, varying span & color
  stat_smooth(se = FALSE, color = "red", span = 0.9) +
  stat_smooth(se = FALSE, color = "green", span = 0.6) +
  stat_smooth(se = FALSE, color = "blue", span = 0.3)
```

<div class="exercise--instructions__content">
<p>Compare LOESS and linear regression smoothing on small regions of data.</p>
<ul>
<li>Add a smooth LOESS stat, without the standard error ribbon.</li>
<li>Add a smooth linear regression stat, again without the standard error ribbon.</li>
</ul>
</div>
```{r}
# Amend the plot to color by fcyl
ggplot(mtcars, aes(x = wt, y = mpg, color = fcyl)) +
  geom_point() +
  # Add a smooth LOESS stat, no ribbon
  stat_smooth(se = FALSE) +
  # Add a smooth lin. reg. stat, no ribbon
  stat_smooth(method = "lm", se = FALSE)
```

<div class="exercise--instructions__content">
<p>LOESS isn't great on very short sections of data; compare the pieces of linear regression to LOESS over the whole thing.</p>
<ul>
<li>Amend the smooth LOESS stat to map <code>color</code> to a dummy variable, <code>"All"</code>.</li>
</ul>
</div>
```{r}
# Amend the plot
ggplot(mtcars, aes(x = wt, y = mpg, color = fcyl)) +
  geom_point() +
  # Map color to dummy variable "All"
  stat_smooth(aes(color = "All"), se = FALSE) +
  stat_smooth(method = "lm", se = FALSE)
```

<p class="">Spantastic! The default span for LOESS is 0.9. A lower span will result in a better fit with more detail; but don't overdo it or you'll end up over-fitting!
</p>

##### Modifying stat_smooth (2) {.unnumbered}


<div class>
<p>In this exercise we'll take a look at the standard error ribbons, which show the 95% confidence interval of smoothing models. <code>ggplot2</code> and the <code>Vocab</code> data frame are already loaded for you.</p>
<p><code>Vocab</code> has been given an extra column, <code>year_group</code>, splitting the dates into before and after 1995.</p>
</div>


```{r}
# edited/added
library(carData)
Vocab <- Vocab %>% 
  mutate(year_group = as.factor(ifelse(year<1995, "[1974,1995]", "[1995,2016]") ))
```
<li>Using <code>Vocab</code>, plot <code>vocabulary</code> vs. <code>education</code>, colored by <code>year_group</code>.</li>
<li>Use <code>geom_jitter()</code> to add jittered points with transparency <code>0.25</code>.</li>
<li>Add a smooth linear regression stat (with the standard error ribbon).</li>
```{r}
# Plot vocabulary vs. education, colored by year_group
ggplot(Vocab, aes(x = education, y = vocabulary, color = year_group)) +
  # Add jittered points with transparency 0.25
  geom_jitter(alpha = 0.25) +
  # Add a smooth lin. reg. line (with ribbon)
  stat_smooth(method = "lm")
```


<div class="exercise--instructions__content">
<p>It's easier to read the plot if the standard error ribbons match the lines, and the lines have more emphasis.</p>
<ul>
<li>Update the smooth stat.<ul>
<li>Map the fill color to <code>year_group</code>.</li>
<li>Set the line size to <code>2</code>.</li>
</ul>
</li>
</ul>
</div>
```{r}
# Amend the plot
ggplot(Vocab, aes(x = education, y = vocabulary, color = year_group)) +
  geom_jitter(alpha = 0.25) +
  # Map the fill color to year_group, set the line size to 2
  stat_smooth(aes(fill = year_group), method = "lm", size = 2)
```

<p class="">You have a vast plotting vocabulary! Notice that since 1995, education has relatively smaller effect on increasing vocabulary.
</p>

#### Stats: sum and quantile {.unnumbered}



##### Quantiles {.unnumbered}


<div class>
<p>Here, we'll continue with the <code>Vocab</code> dataset and use <code>stat_quantile()</code> to apply a quantile regression.</p>
<p>Linear regression predicts the mean response from the explanatory variables, quantile regression predicts a quantile response (e.g. the median) from the explanatory variables. Specific quantiles can be specified with the <code>quantiles</code> argument.</p>
<p>Specifying many quantiles <em>and</em> color your models according to year can make plots too busy. We'll explore ways of dealing with this in the next chapter.</p>
</div>



<li>Update the plot to add a quantile regression stat, at <code>quantiles</code> <code>0.05</code>, <code>0.5</code>, and <code>0.95</code>.</li>





<li>Amend the plot to color according to <code>year_group</code>.</li>
```{r}
# Amend the plot to color by year_group
ggplot(Vocab, aes(x = education, y = vocabulary, color = year_group)) +
  geom_jitter(alpha = 0.25) +
  # Add a quantile stat, at 0.05, 0.5, and 0.95
  stat_quantile(quantiles = c(0.05, 0.5, 0.95))
```

<p class="">Quick quantiles! Quantile regression is a great tool for getting a more detailed overview of a large dataset.
</p>

##### Using stat_sum {.unnumbered}


<div class>
<p>In the <code>Vocab</code> dataset, <code>education</code> and <code>vocabulary</code> are integer variables. In the first course, you saw that this is one of the four causes of overplotting. You'd get a single point at each intersection between the two variables.</p>
<p>One solution, shown in the step 1, is jittering with transparency. Another solution is to use <code>stat_sum()</code>, which calculates the total number of overlapping observations and maps that onto the <code>size</code> aesthetic.</p>
<p><code>stat_sum()</code> allows a special variable, <code>..prop..</code>, to show the <em>proportion</em> of values within the dataset.</p>
</div>



<li>Run the code to see how jittering &amp; transparency solves overplotting.</li>
<li>Replace the jittered points with a sum stat, using <code>stat_sum()</code>.</li>
```{r}
# Run this, look at the plot, then update it
ggplot(Vocab, aes(x = education, y = vocabulary)) +
  # Replace this with a sum stat
  stat_sum()
```


<div class="exercise--instructions__content">
<p>Modify the size <em>aesthetic</em> with the appropriate scale function.</p>
<ul>
<li>Add a <code>scale_size()</code> function to set the <code>range</code> from <code>1</code> to <code>10</code>.</li>
</ul>
</div>
```{r}
ggplot(Vocab, aes(x = education, y = vocabulary)) +
  stat_sum() +
  # Add a size scale, from 1 to 10
  scale_size(range = c(1, 10))
```

<div class="exercise--instructions__content"><p>Inside <code>stat_sum()</code>, set <code>size</code> to <code>..prop..</code> so circle size represents the proportion of the whole dataset.</p></div>
```{r}
# Amend the stat to use proportion sizes
ggplot(Vocab, aes(x = education, y = vocabulary)) +
  stat_sum(aes(size = ..prop..))
```

<div class="exercise--instructions__content"><p>Update the plot to group by <code>education</code>, so that circle size represents the proportion of the group.</p></div>
```{r}
# Amend the plot to group by education
ggplot(Vocab, aes(x = education, y = vocabulary, group = education)) +
  stat_sum(aes(size = ..prop..))
```

<p class="">Superb stat summing! If a few data points overlap, jittering is great. When you have lots of overlaps (particularly where continuous data has been rounded), using <code>stat_sum()</code> to count the overlaps is more useful.
</p>

#### Stats outside geoms {.unnumbered}



##### Preparations {.unnumbered}


<div class>
<p>In the following exercises, we'll aim to make the plot shown in the viewer. Here, we'll establish our positions and base layer of the plot.</p>
<p>Establishing these items as independent objects will allow us to recycle them easily in many layers, or plots.</p>
<ul>
<li>
<code>position_jitter()</code> adds <em>jittering</em> (e.g. for points).</li>
<li>
<code>position_dodge()</code> <em>dodges</em> geoms, (e.g. bar, col, boxplot, violin, errorbar, pointrange).</li>
<li>
<code>position_jitterdodge()</code> <em>jitters</em> <strong>and</strong> <em>dodges</em> geoms, (e.g. points).</li>
</ul>
<p>As before, we'll use <code>mtcars</code>, where <code>fcyl</code> and <code>fam</code> are proper factor variables of the original <code>cyl</code> and <code>am</code> variables.</p>
</div>



<li>Using these three functions, define these position objects:</li>
<li>
<code>posn_j</code>: will <em>jitter</em> with a <code>width</code> of <code>0.2</code>.</li>
<li>
<code>posn_d</code>: will <em>dodge</em> with a <code>width</code> of <code>0.1</code>.</li>
<li>
<code>posn_jd</code> will <em>jitter</em> <strong>and</strong> <em>dodge</em> with a <code>jitter.width</code> of <code>0.2</code> and a <code>dodge.width</code> of <code>0.1</code>.</li>
```{r}
# Define position objects
# 1. Jitter with width 0.2
posn_j <- position_jitter(width = 0.2)

# 2. Dodge with width 0.1
posn_d <- position_dodge(width = 0.1)

# 3. Jitter-dodge with jitter.width 0.2 and dodge.width 0.1
posn_jd <- position_jitterdodge(jitter.width = 0.2, dodge.width = 0.1)
```


<li>Plot <code>wt</code> vs. <code>fcyl</code>, colored by <code>fam</code>. Assign this base layer to <code>p_wt_vs_fcyl_by_fam</code>.</li>
<li>Plot the data using <code>geom_point()</code>.</li>
```{r}
# Create the plot base: wt vs. fcyl, colored by fam
p_wt_vs_fcyl_by_fam <- ggplot(mtcars, aes(x = fcyl, y = wt, color = fam))

# Add a point layer
p_wt_vs_fcyl_by_fam +
  geom_point()
```

<p class="">Patient preparation! The default positioning of the points is highly susceptible to overplotting.
</p>

##### Using position objects {.unnumbered}


<div class>
<p>Now that the position objects have been created, you can apply them to the base plot to see their effects. You do this by adding a point geom and setting the <code>position</code> argument to the position object.</p>
<p>The variables from the last exercise, <code>posn_j</code>, <code>posn_d</code>, <code>posn_jd</code>, and <code>p_wt_vs_fcyl_by_fam</code> are available in your workspace.</p>
</div>
<div class="exercise--instructions__content"><p>Apply the jitter position, <code>posn_j</code>, to the base plot.</p></div>
```{r}
# Add jittering only
p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_j)
```

<div class="exercise--instructions__content"><p>Apply the dodge position, <code>posn_d</code>, to the base plot.</p></div>
```{r}
# Add dodging only
p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_d)
```

<div class="exercise--instructions__content"><p>Apply the jitter-dodge position, <code>posn_jd</code>, to the base plot.</p></div>
```{r}
# Add jittering and dodging
p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_jd)
```

<p class="">Perfect positioning! Although you can set position by setting the <code>position</code> argument to a string (for example <code>position = "dodge"</code>), defining objects promotes consistency between layers.
</p>

##### Plotting variations {.unnumbered}


<div class>
<p>The preparation is done; now let's explore <code>stat_summary()</code>.</p>
<p><em>Summary statistics</em> refers to a combination of <em>location</em> (mean or median) and <em>spread</em> (standard deviation or confidence interval).</p>
<p>These metrics are calculated in <code>stat_summary()</code> by passing a function to the <code>fun.data</code> argument. <code>mean_sdl()</code>, calculates multiples of the standard deviation and <code>mean_cl_normal()</code> calculates the t-corrected 95% CI.</p>
<p>Arguments to the data function are passed to <code>stat_summary()</code>'s <code>fun.args</code> argument as a list.</p>
<p>The position object, <code>posn_d</code>, and the plot with jittered points, <code>p_wt_vs_fcyl_by_fam_jit</code>, are available.</p>
</div>



```{r}
# edited/added
p_wt_vs_fcyl_by_fam_jit <- p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_d)

p_wt_vs_fcyl_by_fam_jit
```
<li>Add error bars representing the standard deviation.<ul>
<li>Set the data function to <code>mean_sdl</code> (without parentheses).</li>
<li>Draw 1 standard deviation each side of the mean, pass arguments to the <code>mean_sdl()</code> function by assigning them to <code>fun.args</code> in the form of a list.</li>
<li>Use <code>posn_d</code> to set the position.</li>
</ul>
</li>
```{r}
p_wt_vs_fcyl_by_fam_jit +
  # Add a summary stat of std deviation limits
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), position = posn_d)
```


<div class="exercise--instructions__content">
<p>The default geom for <code>stat_summary()</code> is <code>"pointrange"</code> which is already great.</p>
<ul>
<li>Update the summary stat to use an <code>"errorbar"</code> geom by assigning it to the <code>geom</code> argument.</li>
</ul>
</div>
```{r}
p_wt_vs_fcyl_by_fam_jit +
  # Change the geom to be an errorbar
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), position = posn_d, geom = "errorbar")
```



<li>Update the plot to add a summary stat of 95% confidence limits.</li>
<li>Set the data function to <code>mean_cl_normal</code> (without parentheses).</li>
<li>Again, use the dodge position.</li>
```{r}
p_wt_vs_fcyl_by_fam_jit +
  # Add a summary stat of normal confidence limits
  stat_summary(fun.data = mean_cl_normal, position = posn_d)
```

<p class="">Good job! You can always assign your own function to the <code>fun.data</code> argument as long as the result is a data frame and the variable names match the aesthetics that you will need for the geom layer.
</p>

### Coordinates {.unnumbered}

<p class="chapter__description">
    The Coordinates layers offer specific and very useful tools for efficiently and accurately communicating data. Here we’ll look at the various ways of effectively using these layers, so you can clearly visualize lognormal datasets, variables with units, and periodic data.
  </p>

#### Coordinates {.unnumbered}



##### Zooming In {.unnumbered}


<div class>
<p>In the video, you saw different ways of using the coordinates layer to zoom in. In this exercise, we'll compare zooming by changing scales and by changing coordinates.</p>
<p>The big difference is that the scale functions change the underlying dataset, which affects calculations made by computed geoms (like histograms or smooth trend lines), whereas coordinate functions make no changes to the dataset.</p>
<p>A scatter plot using <code>mtcars</code> with a LOESS smoothed trend line is provided. Take a look at this before updating it.</p>
</div>
<div class="exercise--instructions__content"><p>Update the plot by adding (<code>+</code>) a continuous x scale with <code>limits</code> from <code>3</code> to <code>6</code>. <em>Spoiler: this will cause a problem!</em></p></div>
```{r}
# Run the code, view the plot, then update it
ggplot(mtcars, aes(x = wt, y = hp, color = fam)) +
  geom_point() +
  geom_smooth() +
  # Add a continuous x scale with x limits from 3 to 6
  scale_x_continuous(limits = c(3, 6))
```

<div class="exercise--instructions__content"><p>Update the plot by adding a Cartesian coordinate system with x limits, <code>xlim</code>, from <code>3</code> to <code>6</code>.</p></div>
```{r}
ggplot(mtcars, aes(x = wt, y = hp, color = fam)) +
  geom_point() +
  geom_smooth() +
  # Add Cartesian coordinates with x limits from 3 to 6
  coord_cartesian(xlim = c(3, 6))
```

<p class="">Zesty zooming! Using the scale function to zoom in meant that there wasn't enough data to calculate the trend line, and <code>geom_smooth()</code> failed. When <code>coord_cartesian()</code> was applied, the full dataset was used for the trend calculation.
</p>

##### Aspect ratio I: 1:1 ratios {.unnumbered}


<div class>
<p>We can set the aspect ratio of a plot with <code>coord_fixed()</code>, which uses <code>ratio = 1</code> as a default. A 1:1 aspect ratio is most appropriate when two continuous variables are on the same scale, as with the <code>iris</code> dataset.</p>
<p>All variables are measured in centimeters, so it only makes sense that one unit on the plot should be the same physical distance on each axis. This gives a more truthful depiction of the relationship between the two variables since the aspect ratio can change the angle of our smoothing line. This would give an erroneous impression of the data. Of course the underlying linear models don't change, but our perception can be influenced by the angle drawn.</p>
<p>A plot using the <code>iris</code> dataset, of sepal width vs. sepal length colored by species, is shown in the viewer.</p>
</div>



<li>Add a fixed coordinate layer to force a 1:1 aspect ratio.</li>
```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_jitter() +
  geom_smooth(method = "lm", se = FALSE) +
  # Fix the coordinate ratio
  coord_fixed()
```

<p class="">Awe-inspiring aspect alteration! A 1:1 aspect ratio is helpful when your axes show the same scales.
</p>

##### Aspect ratio II: setting ratios {.unnumbered}


<div class>
<p>When values are not on the same scale it can be a bit tricky to set an appropriate aspect ratio. A classic William Cleveland (inventor of dot plots) example is the <code>sunspots</code> data set. We have 3200 observations from 1750 to 2016.</p>
<p><code>sun_plot</code> is a plot <em>without</em> any set aspect ratio. It fills up the graphics device.</p>
<p>To make aspect ratios clear, we've drawn an orange box that is 75 units high and 75 <em>years</em> wide. Using a 1:1 aspect ratio would make the box square. That aspect ratio would make things harder to see the oscillations: it is better to force a wider ratio.</p>
</div>


```{r}
# edited/added
library(zoo)
sunspots.m <- data.frame(
year = index(sunspot.month),
value = reshape2::melt(sunspot.month)$value)
sun_plot <- ggplot(sunspots.m, aes(x = year, y = value)) +
  geom_line() +
  coord_fixed() # default to 1:1 aspect ratio

sun_plot
```
<li>Fix the coordinates to a 1:1 aspect ratio.</li>
```{r}
# Fix the aspect ratio to 1:1
sun_plot +
  coord_fixed()
```


<div class="exercise--instructions__content">
<p>The <code>y</code> axis is now unreadably small. Make it bigger!</p>
<ul>
<li>Change the aspect <code>ratio</code> to 20:1. This is the aspect ratio recommended by Cleveland to help make the trend among oscillations easiest to see.</li>
</ul>
</div>
```{r}
# Change the aspect ratio to 20:1
sun_plot +
  coord_fixed(ratio = 0.05) # edited/added
```

<p class="">Fun plots with sunspots! Making a wide plot by calling <code>coord_fixed()</code> with a high <code>ratio</code> is often useful for long time series.
</p>

##### Expand and clip {.unnumbered}


<div class>
<p>The <code>coord_*()</code> layer functions offer two useful arguments that work well together: <code>expand</code> and <code>clip</code>.</p>
<ul>
<li>
<code>expand</code> sets a buffer margin around the plot, so data and axes don't overlap. Setting <code>expand</code> to <code>0</code> draws the axes to the limits of the data.</li>
<li>
<code>clip</code> decides whether plot elements that would lie outside the plot panel are displayed or ignored ("clipped").</li>
</ul>
<p>When done properly this can make a great visual effect! We'll use <code>theme_classic()</code> and modify the axis lines in this example.</p>
</div>



<li>Add Cartesian coordinates with zero expansion, to remove all buffer margins on both the x and y axes.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(size = 2) +
  theme_classic() +
  # Add Cartesian coordinates with zero expansion
  coord_cartesian(expand = 0)
```


<div class="exercise--instructions__content">
<p>Setting <code>expand</code> to <code>0</code> caused points at the edge of the plot panel to be cut off.</p>
<ul>
<li>Set the <code>clip</code> argument to <code>"off"</code> to prevent this.</li>
<li>Remove the axis lines by setting the <code>axis.line</code> argument to <code>element_blank()</code> in the <code>theme()</code> layer function.</li>
</ul>
</div>
```{r}
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(size = 2) +
  # Turn clipping off
  coord_cartesian(expand = 0, clip = "off") +
  theme_classic() +
  # Remove axis lines
  theme(axis.line = element_blank())
```

<p class="">Cool clipping! These arguments make clean and accurate plots by not cutting off data.
</p>

#### Coordinates vs. scales {.unnumbered}



##### Log-transforming scales {.unnumbered}


<div class>
<p>Using <code>scale_y_log10()</code> and <code>scale_x_log10()</code> is equivalent to transforming our actual dataset <em>before</em> getting to <code>ggplot2</code>.</p>
<p>Using <code>coord_trans()</code>, setting <code>x = "log10"</code> and/or <code>y = "log10"</code> arguments, transforms the data <em>after</em> statistics have been calculated. The plot will look the same as with using <code>scale_*_log10()</code>, but the scales will be different, meaning that we'll see the original values on our log10 transformed axes. This can be useful since log scales can be somewhat unintuitive.</p>
<p>Let's see this in action with positively skewed data - the brain and body weight of 51 mammals from the <code>msleep</code> dataset.</p>
</div>



<li>Using the <code>msleep</code> dataset, plot the raw values of <code>brainwt</code> against <code>bodywt</code> values as a scatter plot.</li>
```{r}
# Produce a scatter plot of brainwt vs. bodywt
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  ggtitle("Raw Values")
```





<li>Add the <code>scale_x_log10()</code> and <code>scale_y_log10()</code> layers with default values to transform the data before plotting.</li>
```{r}
# Add scale_*_*() functions
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  ggtitle("Scale_ functions")
```




<li>Use <code>coord_trans()</code> to apply a <code>"log10"</code> transformation to both the <code>x</code> and <code>y</code> scales.</li>
```{r}
# Perform a log10 coordinate system transformation
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  coord_trans(x = "log10", y = "log10")
```

<p class="">Terrific transformations! Each transformation method has implications for the plot's interpretability. Think about your audience when choosing a method for applying transformations.
</p>

##### Adding stats to transformed scales {.unnumbered}


<div class><p>In the last exercise, we saw the usefulness of the <code>coord_trans()</code> function, but be careful! Remember that statistics are calculated on the untransformed data. A linear model may end up looking not-so-linear after an axis transformation. Let's revisit the two plots from the previous exercise and compare their linear models.</p></div>
<div class="exercise--instructions__content"><p>Add log10 transformed scales to the x and y axes.</p></div>
```{r}
# Plot with a scale_*_*() function:
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  # Add a log10 x scale
  scale_x_log10() +
  # Add a log10 y scale
  scale_y_log10() +
  ggtitle("Scale_ functions")
```




<li>Add a log10 coordinate transformation for both the x and y axes.</li>
<li><em>Do you notice the difference between the two plots?</em></li>
```{r}
# Plot with transformed coordinates
ggplot(msleep, aes(bodywt, brainwt)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  # Add a log10 coordinate transformation for x and y axes
  coord_trans(x = "log10", y = "log10")
```

<p class="">Loopy lines! The smooth trend line is calculated after scale transformations but not coordinate transformations, so the second plot doesn't make sense. Be careful when using the <code>coord_trans()</code> function!
</p>

#### Double and flipped axes {.unnumbered}



##### Useful double axes {.unnumbered}


<div class>
<p>Double x and y-axes are a contentious topic in data visualization. We'll revisit that discussion at the end of chapter 4. Here, I want to review a great use case where double axes actually do add value to a plot.</p>
<p>Our goal plot is displayed in the viewer. The two axes are the raw temperature values on a Fahrenheit scale and the transformed values on a Celsius scale.</p>
<p>You can imagine a similar scenario for Log-transformed and original values, miles and kilometers, or pounds and kilograms. A scale that is unintuitive for many people can be made easier by adding a transformation as a double axis.</p>
</div>
```{r}
# edited/added
library(lubridate)
airquality <- airquality %>% 
  mutate(Date = make_date(1974, Month, Day))
```

<div class="exercise--instructions__content"><p>Begin with a standard line plot, of <code>Temp</code> described by <code>Date</code> in the <code>airquality</code> dataset.</p></div>
```{r}
# Using airquality, plot Temp vs. Date
ggplot(airquality, aes(x = Date, y = Temp)) +
  # Add a line layer
  geom_line() +
  labs(x = "Date (1973)", y = "Fahrenheit")
```


<li>Convert <code>y_breaks</code> from Fahrenheit to Celsius (subtract 32, then multiply by 5, then divide by 9).</li>
<li>Define the secondary y-axis using <code>sec_axis()</code>. Use the <code>identity</code> transformation. Set the <code>breaks</code> and <code>labels</code> to the defined objects <code>y_breaks</code> and <code>y_labels</code>, respectively.</li>
```{r}
# Define breaks (Fahrenheit)
y_breaks <- c(59, 68, 77, 86, 95, 104)

# Convert y_breaks from Fahrenheit to Celsius
y_labels <- (y_breaks - 32) * 5 / 9

# Create a secondary x-axis
secondary_y_axis <- sec_axis(
  # Use identity transformation
  trans = identity,
  name = "Celsius",
  # Define breaks and labels as above
  breaks = y_breaks,
  labels = y_labels
)

# Examine the object
secondary_y_axis
```

<li>Add your secondary y-axis to the <code>sec.axis</code> argument of <code>scale_y_continuous()</code>.</li>
```{r}
# Update the plot
ggplot(airquality, aes(x = Date, y = Temp)) +
  geom_line() +
  # Add the secondary y-axis 
  scale_y_continuous(sec.axis = secondary_y_axis) +
  labs(x = "Date (1973)", y = "Fahrenheit")
```

<p class="">Dazzling double axes! Double axes are most useful when you want to display the same value in two differnt units.
</p>

##### Flipping axes I {.unnumbered}


<div class>
<p><em>Flipping</em> axes means to reverse the variables mapped onto the <code>x</code> and <code>y</code> aesthetics. We can just change the mappings in <code>aes()</code>, but we can also use the <code>coord_flip()</code> layer function.</p>
<p>There are two reasons to use this function:</p>
<ul>
<li>We want a vertical geom to be horizontal, or</li>
<li>We've completed a long series of plotting functions and want to flip it without having to rewrite all our commands.</li>
</ul>
</div>



<li>Create a side-by-side ("dodged") bar chart of <code>fam</code>, filled according to <code>fcyl</code>.</li>
```{r}
# Plot fcyl bars, filled by fam
ggplot(mtcars, aes(fcyl, fill = fam)) +
  # Place bars side by side
  geom_bar(position = "dodge")
```





<li>To get horizontal bars, add a <code>coord_flip()</code> function.</li>
```{r}
ggplot(mtcars, aes(fcyl, fill = fam)) +
  geom_bar(position = "dodge") +
  # Flip the x and y coordinates
  coord_flip()
```




<li>Partially overlapping bars are popular with "infoviz" in magazines. Update the <code>position</code> argument to use <code>position_dodge()</code> with a width of <code>0.5</code>.</li>
```{r}
ggplot(mtcars, aes(fcyl, fill = fam)) +
  # Set a dodge width of 0.5 for partially overlapping bars
  geom_bar(position = position_dodge(0.5)) +
  coord_flip()
```

<p class="">Flipping fantastic! Horizontal bars are especially useful when the axis labels are long.
</p>

##### Flipping axes II {.unnumbered}


<div class>
<p>In this exercise, we'll continue to use the <code>coord_flip()</code> layer function to reverse the variables mapped onto the <code>x</code> and <code>y</code> aesthetics.</p>
<p>Within the <code>mtcars</code> dataset, <code>car</code> is the name of the car and <code>wt</code> is its weight.</p>
</div>


```{r}
# edited/added
mtcars <- read.csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vQL7M2s7mq4cBnS0wqTfubhhX6UBofELw2yRPcKRQqVQTra_-vpXIVqPxICaVAx7o470W-X_E3-YzNc/pub?gid=1571215697&single=true&output=csv", stringsAsFactors=FALSE)
mtcars <- mtcars %>% 
  mutate(fam = as.factor(am), fcyl = as.factor(cyl), car = model, fvs = as.factor(vs))
```
<li>Create a scatter plot of <code>wt</code> versus <code>car</code> using the <code>mtcars</code> dataset. We'll flip the axes in the next step.</li>
```{r}
# Plot of wt vs. car
ggplot(mtcars, aes(car, wt)) +
  # Add a point layer
  geom_point() +
  labs(x = "car", y = "weight")
```

<li>It would be easier to read if <code>car</code> was mapped to the y axis. Flip the coordinates. <em>Notice that the labels also get flipped!</em></li>
```{r}
# Flip the axes to set car to the y axis
ggplot(mtcars, aes(car, wt)) +
  geom_point() +
  labs(x = "car", y = "weight") +
  coord_flip()
```

<p class="">Even funkier flips! Notice how much more interpretable the plot is after flipping the axes.
</p>

#### Polar coordinates {.unnumbered}



##### Pie charts {.unnumbered}


<div class>
<p>The <code>coord_polar()</code> function converts a planar x-y Cartesian plot to polar coordinates. This can be useful if you are producing pie charts.</p>
<p>We can imagine two forms for pie charts - the typical filled circle, or a colored ring.</p>
<p>Typical pie charts omit all of the non-data ink, which we saw in the themes chapter of the last course. Pie charts are not really better than stacked bar charts, but we'll come back to this point in the next chapter.</p>
<p>A bar plot using <code>mtcars</code> of the number of cylinders (as a factor), <code>fcyl</code>, is shown in the console.</p>
</div>



<li><em>Run the code to see the stacked bar plot.</em></li>
<li>Add (<code>+</code>) a polar coordinate system, mapping the angle to the <code>y</code> variable by setting <code>theta</code> to <code>"y"</code>.</li>
```{r}
# Run the code, view the plot, then update it
ggplot(mtcars, aes(x = 1, fill = fcyl)) +
  geom_bar() +
  # Add a polar coordinate system
  coord_polar(theta = "y")
```





<li>Reduce the <code>width</code> of the bars to <code>0.1</code>.</li>
<li>Make it a ring plot by adding a continuous x scale with limits from <code>0.5</code> to <code>1.5</code>.</li>
```{r}
ggplot(mtcars, aes(x = 1, fill = fcyl)) +
  # Reduce the bar width to 0.1
  geom_bar(width = 0.1) +
  coord_polar(theta = "y") +
  # Add a continuous x scale from 0.5 to 1.5
  scale_x_continuous(limits = c(0.5, 1.5))
```

<p class="">Super-fly pie! Polar coordinates are particularly useful if you are dealing with a cycle, like yearly data, that you would like to see represented as such.
</p>

##### Wind rose plots {.unnumbered}


<div class>
<p>Polar coordinate plots are well-suited to scales like compass direction or time of day. A popular example is the "wind rose".</p>
<p>The <code>wind</code> dataset is taken from the <code>openair</code> package and contains hourly measurements for windspeed (<code>ws</code>) and direction (<code>wd</code>) from London in 2003. Both variables are factors.</p>
</div>


```{r}
# edited/added
wind = read.csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vQL7M2s7mq4cBnS0wqTfubhhX6UBofELw2yRPcKRQqVQTra_-vpXIVqPxICaVAx7o470W-X_E3-YzNc/pub?gid=730475480&single=true&output=csv")
```
<li>Make a classic bar plot mapping <code>wd</code> onto the <code>x</code> aesthetic and <code>ws</code> onto <code>fill</code>.</li>
<li>Use a <code>geom_bar()</code> layer, since we want to aggregate over all date values, and set the <code>width</code> argument to 1, to eliminate any spaces between the bars.</li>
```{r}
# Using wind, plot wd filled by ws
ggplot(wind, aes(wd, fill = ws)) +
  # Add a bar layer with width 1
  geom_bar(width = 1)
```

<li>Convert the Cartesian coordinate space into a polar coordinate space with <code>coord_polar()</code>.</li>
```{r}
# Convert to polar coordinates:
ggplot(wind, aes(wd, fill = ws)) +
  geom_bar(width = 1) +
  coord_polar()
```

<li>Set the <code>start</code> argument to <code>-pi/16</code> to position North at the top of the plot.</li>
```{r}
# Convert to polar coordinates:
ggplot(wind, aes(wd, fill = ws)) +
  geom_bar(width = 1) +
  coord_polar(start = -pi/16)
```

<p class="">Perfect polar coordinates! They are not common, but polar coordinate plots are really useful.
</p>

### Facets {.unnumbered}

<p class="chapter__description">
    Facets let you split plots into multiple panes, each displaying subsets of the dataset. Here you'll learn how to wrap facets and arrange them in a grid, as well as providing custom labeling.
  </p>

#### The facets layer {.unnumbered}



##### Facet layer basics {.unnumbered}


<div class>
<p>Faceting splits the data up into groups, according to a categorical variable, then plots each group in its own panel. For splitting the data by one or two categorical variables, <code>facet_grid()</code> is best.</p>
<p>Given categorical variables <code>A</code> and <code>B</code>, the code pattern is</p>
<pre><code>plot +
  facet_grid(rows = vars(A), cols = vars(B))
</code></pre>
<p>This draws a panel for each pairwise combination of the values of <code>A</code> and <code>B</code>.</p>
<p>Here, we'll use the <code>mtcars</code> data set to practice. Although <code>cyl</code> and <code>am</code> are not encoded as factor variables in the data set, <code>ggplot2</code> will coerce variables to factors when used in facets.</p>
</div>



<li>Facet the plot in a grid, with each <code>am</code> value in its own row.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) + 
  geom_point() +
  # Facet rows by am
  facet_grid(rows = vars(am))
```





<li>Facet the plot in a grid, with each <code>cyl</code> value in its own column.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) + 
  geom_point() +
  # Facet columns by cyl
  facet_grid(cols = vars(cyl))
```




<li>Facet the plot in a grid, with each <code>am</code> value in its own row and each <code>cyl</code> value in its own column.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) + 
  geom_point() +
  # Facet rows by am and columns by cyl
  facet_grid(rows = vars(am), cols = vars(cyl))
```

<p class="">Fantastic faceting! Compare the different plots that result and see which one makes most sense.
</p>

##### Many variables {.unnumbered}


<div class>
<p>In addition to aesthetics, facets are another way of encoding factor (i.e. categorical) variables. They can be used to reduce the complexity of plots with many variables.</p>
<p>Our goal is the plot in the viewer, which contains 7 variables.</p>
<p>Two variables are mapped onto the color aesthetic, using hue and lightness. To achieve this we combined <code>fcyl</code> and <code>fam</code> into a single <a href="https://www.rdocumentation.org/packages/base/topics/interaction">interaction</a> variable, <code>fcyl_fam</code>. This will allow us to take advantage of Color Brewer's <em>Paired</em> color palette.</p>
</div>


```{r}
# edited/added
mtcars <- mtcars %>% 
  mutate(fcyl_fam = interaction(fcyl, fam, sep=":"))
```
<li>Map <code>fcyl_fam</code> onto the a <code>color</code> aesthetic.</li>
<li>Add a <code>scale_color_brewer()</code> layer and set <code>"Paired"</code> as the <code>palette</code>.</li>
```{r}
# See the interaction column
mtcars$fcyl_fam

# Color the points by fcyl_fam
ggplot(mtcars, aes(x = wt, y = mpg, color = fcyl_fam)) +
  geom_point() +
  # Use a paired color palette
  scale_color_brewer(palette = "Paired")
```





<li>Map <code>disp</code>, the displacement volume from each cylinder, onto the <code>size</code> aesthetic.</li>
```{r}
# Update the plot to map disp to size
ggplot(mtcars, aes(x = wt, y = mpg, color = fcyl_fam, size = disp)) +
  geom_point() +
  scale_color_brewer(palette = "Paired")
```

<div class="exercise--instructions__content"><p>Add a <code>facet_grid()</code> layer, faceting the plot according to <code>gear</code> on rows and <code>vs</code> on columns.</p></div>
```{r}
# Update the plot
ggplot(mtcars, aes(x = wt, y = mpg, color = fcyl_fam, size = disp)) +
  geom_point() +
  scale_color_brewer(palette = "Paired") +
  # Grid facet on gear and vs
  facet_grid(rows = vars(gear), cols = vars(vs))
```

<p class="">Good job! The last plot you've created contains 7 variables (4 categorical, 3 continuous). Useful combinations of aesthetics and facets help to achieve this.
</p>

##### Formula notation {.unnumbered}


<div class>
<p>As well as the <code>vars()</code> notation for specifying which variables should be used to split the dataset into facets, there is also a traditional formula notation. The three cases are shown in the table.</p>
<pre><code>| Modern notation                            | Formula notation  |
|--------------------------------------------|-------------------|
| facet_grid(rows = vars(A))                 | facet_grid(A ~ .) |
| facet_grid(cols = vars(B))                 | facet_grid(. ~ B) |
| facet_grid(rows = vars(A), cols = vars(B)) | facet_grid(A ~ B) |
</code></pre>
<p><code>mpg_by_wt</code> is available again. Rework the previous plots, this time using formula notation.</p>
</div>



<li>Facet the plot in a grid, with each <code>am</code> value in its own row.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) + 
  geom_point() +
  # Facet rows by am using formula notation
  facet_grid(am ~ .)
```





<li>Facet the plot in a grid, with each <code>cyl</code> value in its own column.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) + 
  geom_point() +
  # Facet columns by cyl using formula notation
  facet_grid(. ~ cyl)
```




<li>Facet the plot in a grid, with each <code>am</code> value in its own row and each <code>cyl</code> value in its own column.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) + 
  geom_point() +
  # Facet rows by am and columns by cyl using formula notation
  facet_grid(am ~ cyl)
```

<p class="">Fortunate formula formulation! While many ggplots still use the traditional formula notation, using <code>vars()</code> is now preferred.
</p>

#### Facet labels and order {.unnumbered}



##### Labeling facets {.unnumbered}


<div class>
<p>If your factor levels are not clear, your facet labels may be confusing. You can assign proper labels in your original data <em>before</em> plotting (see next exercise), or you can use the <code>labeller</code> argument in the facet layer.</p>
<p>The default value is</p>
<ul>
<li>
<code>label_value</code>: Default, displays only the value</li>
</ul>
<p>Common alternatives are:</p>
<ul>
<li>
<code>label_both</code>: Displays both the value and the variable name</li>
<li>
<code>label_context</code>: Displays only the values or both the values and variables depending on whether multiple factors are faceted</li>
</ul>
</div>



<li>Add a <code>facet_grid()</code> layer and facet <code>cols</code> according to the <code>cyl</code> using <code>vars()</code>. There is no labeling.</li>
```{r}
# Plot wt by mpg
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  # The default is label_value
  facet_grid(cols = vars(cyl))
```





<li>Apply <code>label_both</code> to the <code>labeller</code> argument and check the output.</li>
```{r}
# Plot wt by mpg
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  # Displaying both the values and the variables
  facet_grid(cols = vars(cyl), labeller = label_both)
```




<li>Apply <code>label_context</code> to the <code>labeller</code> argument and check the output.</li>
```{r}
# Plot wt by mpg
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  # Label context
  facet_grid(cols = vars(cyl), labeller = label_context)
```




<li>In addition to <code>label_context</code>, let's facet by one more variable: <code>vs</code>.</li>
```{r}
# Plot wt by mpg
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  # Two variables
  facet_grid(cols = vars(vs, cyl), labeller = label_context)
```

<p class="">Lovely labels! Make sure there is no ambiguity in interpreting plots by using proper labels.
</p>

##### Setting order {.unnumbered}


<div class>
<p>If you want to change the order of your facets, it's best to properly define your factor variables <em>before</em> plotting.</p>
<p>Let's see this in action with the <code>mtcars</code> transmission variable <code>am</code>. In this case, <code>0</code> = "automatic" and <code>1</code> = "manual".</p>
<p>Here, we'll make <code>am</code> a factor variable and relabel the numbers to proper names. The default order is alphabetical. To rearrange them we'll call <code>fct_rev()</code> from the <code>forcats</code> package to reverse the order.</p>
</div>



<li>Explicitly label the <code>0</code> and <code>1</code> values of the <code>am</code> column as <code>"automatic"</code> and <code>"manual"</code>, respectively.</li>
```{r}
# Make factor, set proper labels explictly
mtcars$fam <- factor(mtcars$am,
                     labels = c(`0` = "automatic",
                                `1` = "manual"))

# Default order is alphabetical
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  facet_grid(cols = vars(fam))
```





<li>Define a specific order using separate <code>levels</code> and <code>labels</code> arguments. Recall that <code>1</code> is <code>"manual"</code> and <code>0</code> is <code>"automatic"</code>.</li>
```{r}
# Make factor, set proper labels explictly, and
# manually set the label order
mtcars$fam <- factor(mtcars$am,
                     levels = c(1, 0),
                     labels = c("manual", "automatic"))

# View again
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  facet_grid(cols = vars(fam))
```

<p class="">Outstanding ordering! Arrange your facets in an intuitive order for your data.
</p>

#### Facet plotting spaces {.unnumbered}



##### Variable plotting spaces I: continuous variables {.unnumbered}


<div class>
<p>By default every facet of a plot has the same axes. If the data ranges vary wildly between facets, it can be clearer if each facet has its own scale. This is achieved with the <code>scales</code> argument to <code>facet_grid()</code>.</p>
<ul>
<li>
<code>"fixed"</code> (default): axes are shared between facets.</li>
<li>
<code>free</code>: each facet has its own axes.</li>
<li>
<code>free_x</code>: each facet has its own x-axis, but the y-axis is shared.</li>
<li>
<code>free_y</code>: each facet has its own y-axis, but the x-axis is shared.</li>
</ul>
<p>When faceting by columns, <code>"free_y"</code> has no effect, but we can adjust the x-axis. In contrast, when faceting by rows, <code>"free_x"</code> has no effect, but we can adjust the y-axis.</p>
</div>



<li>Update the plot to facet columns by <code>cyl</code>.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() + 
  # Facet columns by cyl 
  facet_grid(cols = vars(cyl))
```





<li>Update the faceting to free the x-axis scales.</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() + 
  # Update the faceting to free the x-axis scales
  facet_grid(cols = vars(cyl), scales = "free_x")
```




<li>Facet <strong>rows</strong> by <code>cyl</code> (rather than columns).</li>
<li>Free the <strong>y</strong>-axis scales (instead of x).</li>
```{r}
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() + 
  # Update the faceting to free the y-axis scales
  facet_grid(rows = vars(cyl), scales = "free_y")
```

<p class="">Freedom! Shared scales make it easy to compare between facets, but can be confusing if the data ranges are very different. In that case, used free scales.
</p>

##### Variable plotting spaces II: categorical variables {.unnumbered}


<div class>
<p>When you have a categorical variable with many levels which are not all present in each sub-group of another variable, it's usually desirable to drop the unused levels.</p>
<p>By default, each facet of a plot is the same size. This behavior can be changed with the <code>spaces</code> argument, which works in the same way as <code>scales</code>: <code>"free_x"</code> allows different sized facets on the x-axis, <code>"free_y"</code>, allows different sized facets on the y-axis, <code>"free"</code> allows different sizes in both directions.</p>
</div>



<li>Facet the plot by rows according to <code>gear</code> using <code>vars()</code>. Notice that <em>every</em> car is listed in <em>every</em> facet, resulting in many lines without data.</li>
```{r}
ggplot(mtcars, aes(x = mpg, y = car, color = fam)) +
  geom_point() +
  # Facet rows by gear
  facet_grid(rows = vars(gear))
```





<li>To remove blank lines, set the <code>scales</code> and <code>space</code> arguments in <code>facet_grid()</code> to <code>free_y</code>.</li>
```{r}
ggplot(mtcars, aes(x = mpg, y = car, color = fam)) +
  geom_point() +
  # Free the y scales and space
  facet_grid(rows = vars(gear), scales = "free_y", space = "free_y")
```

<p class="">Super spaces! Freeing the y-scale to remove blank lines helps focus attention on the actual data present.
</p>

#### Facet wrap &amp; margins {.unnumbered}



##### Wrapping for many levels {.unnumbered}


<div class>
<p><code>facet_grid()</code> is fantastic for categorical variables with a small number of levels. Although it is possible to facet variables with many levels, the resulting plot will be very wide or very tall, which can make it difficult to view.</p>
<p>The solution is to use <code>facet_wrap()</code> which separates levels along one axis but wraps all the subsets across a given number of rows or columns.</p>
<p>For this plot, we'll use the <code>Vocab</code> dataset that we've already seen. The base layer is provided.</p>
<p>Since we have many <code>years</code>, it doesn't make sense to use <code>facet_grid()</code>, so let's try <code>facet_wrap()</code> instead.</p>
</div>
<div class="exercise--instructions__content">
<p>Add a facet_wrap() layer and specify:</p>
<ul>
<li>The <code>year</code> variable with an argument using the <code>vars()</code> function,</li>
</ul>
</div>
```{r}
ggplot(Vocab, aes(x = education, y = vocabulary)) +
  stat_smooth(method = "lm", se = FALSE) +
  # Create facets, wrapping by year, using vars()
  facet_wrap(vars(year))
```

<div class="exercise--instructions__content"><p>Add a <code>facet_wrap()</code> layer and specify the <code>year</code> variable with a formula notation (<code>~</code>).</p></div>
```{r}
ggplot(Vocab, aes(x = education, y = vocabulary)) +
  stat_smooth(method = "lm", se = FALSE) +
  # Create facets, wrapping by year, using a formula
  facet_wrap(~ year)
```

<div class="exercise--instructions__content">
<p>Add a <code>facet_wrap()</code> layer and specify:</p>
<ul>
<li>Formula notation as before, and <code>ncol</code> set to <code>11</code>.</li>
</ul>
</div>
```{r}
ggplot(Vocab, aes(x = education, y = vocabulary)) +
  stat_smooth(method = "lm", se = FALSE) +
  # Update the facet layout, using 11 columns
  facet_wrap(~ year, ncol = 11)
```

<p class="">It's a wrap! Start experimenting with facets in your own plots.
</p>

##### Margin plots {.unnumbered}


<div class>
<p>Facets are great for seeing subsets in a variable, but sometimes you want to see <em>both</em> those subsets <em>and</em> all values in a variable.</p>
<p>Here, the <code>margins</code> argument to <code>facet_grid()</code> is your friend.</p>
<ul>
<li>
<code>FALSE</code> (default): no margins.</li>
<li>
<code>TRUE</code>: add margins to every variable being faceted by.</li>
<li>
<code>c("variable1", "variable2")</code>: only add margins to the variables listed.</li>
</ul>
<p>To make it easier to follow the facets, we've created two factor variables with proper labels — <code>fam</code> for the transmission type, and <code>fvs</code> for the engine type, respectively.</p>
<p><em>Zoom the graphics window to better view your plots.</em></p>
</div>
<div class="exercise--instructions__content"><p>Update the plot to facet the rows by <code>fvs</code> and <code>fam</code>, and columns by <code>gear</code>.</p></div>
```{r}
ggplot(mtcars, aes(x = wt, y = mpg)) + 
  geom_point() +
  # Facet rows by fvs and fam, and cols by gear
  facet_grid(rows = vars(fvs, fam), cols = vars(gear))
```

<div class="exercise--instructions__content"><p>Add all possible margins to the plot.</p></div>
```{r}
ggplot(mtcars, aes(x = wt, y = mpg)) + 
  geom_point() +
  # Update the facets to add margins
  facet_grid(rows = vars(fvs, fam), cols = vars(gear), margins = TRUE)
```

<div class="exercise--instructions__content"><p>Update the facets to only show margins on <code>"fam"</code>.</p></div>
```{r}
ggplot(mtcars, aes(x = wt, y = mpg)) + 
  geom_point() +
  # Update the facets to only show margins on fam
  facet_grid(rows = vars(fvs, fam), cols = vars(gear), margins = "fam")
```

<div class="exercise--instructions__content"><p>Update the facets to only show margins on <code>"gear"</code> and <code>"fvs"</code>.</p></div>
```{r}
ggplot(mtcars, aes(x = wt, y = mpg)) + 
  geom_point() +
  # Update the facets to only show margins on gear and fvs
  facet_grid(rows = vars(fvs, fam), cols = vars(gear), margins = c("gear", "fvs"))
```

<p class="">Magic margins! It can be really helpful to show the full margin plots!
</p>

### Best Practices {.unnumbered}

<p class="chapter__description">
    Now that you have the technical skills to make great visualizations, it’s important that you make them as meaningful as possible. In this chapter, you’ll review three plot types that are commonly discouraged in the data viz community: heat maps, pie charts, and dynamite plots. You’ll learn the pitfalls with these plots and how to avoid making these mistakes yourself.
  </p>

#### Best practices: bar plots {.unnumbered}



##### Bar plots: dynamite plots {.unnumbered}


<div class>
<p>In the video we saw many reasons why "dynamite plots" (bar plots with error bars) are <em>not</em> well suited for their intended purpose of depicting distributions. If you <em>really</em> want error bars on bar plots, you can of course get them, but you'll need to set the positions manually. A point geom will typically serve you much better.</p>
<p>Nonetheless, you should know how to handle these kinds of plots, so let's give it a try.</p>
</div>



<li>Using <code>mtcars,</code>, plot <code>wt</code> versus <code>fcyl</code>.</li>
<li>Add a bar summary stat, aggregating the <code>wt</code>s by their mean, filling the bars in a skyblue color.</li>
<li>Add an errorbar summary stat, aggregating the <code>wt</code>s by <code>mean_sdl</code>.</li>
```{r}
# Plot wt vs. fcyl
ggplot(mtcars, aes(x = fcyl, y = wt)) +
  # Add a bar summary stat of means, colored skyblue
  stat_summary(fun.y = mean, geom = "bar", fill = "skyblue") +
  # Add an errorbar summary stat std deviation limits
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", width = 0.1)
```

<p class="">Excellent errors! Remember, we can specify any function in <code>fun.data</code> or <code>fun.y</code> and we can also specify any <code>geom</code>, as long as it's appropriate to the data type.
</p>

##### Bar plots: position dodging {.unnumbered}


<div class>
<p>In the previous exercise we used the <code>mtcars</code> dataset to draw a dynamite plot about the weight of the cars per cylinder type.</p>
<p>In this exercise we will add a distinction between transmission type, <code>fam</code>, for the dynamite plots and explore position dodging (where bars are side-by-side).</p>
</div>
<div class="exercise--instructions__content"><p>Add two more aesthetics so the bars are <code>color</code>ed and <code>fill</code>ed  by <code>fam</code>.</p></div>
```{r}
# Update the aesthetics to color and fill by fam
ggplot(mtcars, aes(x = fcyl, y = wt, color = fam, fill = fam)) +
  stat_summary(fun.y = mean, geom = "bar") +
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", width = 0.1)
```

<div class="exercise--instructions__content"><p>The stacked bars are tricky to interpret. Make them transparent and side-by-side.</p>
<ul>
<li>Make the bar summary statistic transparent by setting <code>alpha</code> to <code>0.5</code>.</li>
<li>For each of the summary statistics, set the bars' position to <code>"dodge"</code>.</li>
</ul></div>
```{r}
# For each summary stat, set the position to dodge
ggplot(mtcars, aes(x = fcyl, y = wt, color = fam, fill = fam)) +
  stat_summary(fun.y = mean, geom = "bar", position = "dodge", alpha = 0.5) +
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", position = "dodge", width = 0.1)
```

<div class="exercise--instructions__content"><p>The error bars are incorrectly positioned. Use a position object.</p>
<ul>
<li>Define a dodge position object with width <code>0.9</code>, assigned to <code>posn_d</code>.</li>
<li>For each of the summary statistics, set the bars' position to <code>posn_d</code>.</li>
</ul></div>
```{r}
# Define a dodge position object with width 0.9
posn_d <- position_dodge(width = 0.9)

# For each summary stat, update the position to posn_d
ggplot(mtcars, aes(x = fcyl, y = wt, color = fam, fill = fam)) +
  stat_summary(fun.y = mean, geom = "bar", position = posn_d, alpha = 0.5) +
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "errorbar", position = posn_d, width = 0.1)
```

<p class="">Bar plots 2.0! Slightly overlapping bar plots are common in the popular press and add a bit of style to your data viz.
</p>

##### Bar plots: Using aggregated data {.unnumbered}


<div class>
<p>If it <em>is</em> appropriate to use bar plots (see the video!), then it nice to give an impression of the number of values in each group.</p>
<p><code>stat_summary()</code> doesn't keep track of the count. <code>stat_sum()</code> does (that's the whole point), but it's difficult to access. It's more straightforward to calculate exactly what we want to plot ourselves.</p>
<p>Here, we've created a summary data frame called <code>mtcars_by_cyl</code> which contains the average (<code>mean_wt</code>), standard deviations (<code>sd_wt</code>) and count (<code>n_wt</code>) of car weights, for each cylinder group, <code>cyl</code>. It also contains the proportion (<code>prop</code>) of each cylinder represented in the entire dataset. Use the console to familiarize yourself with the <code>mtcars_by_cyl</code> data frame.</p>
</div>
```{r}
# edited/added
mtcars_by_cyl <- mtcars %>%
  group_by(cyl) %>% 
  summarize(mean_wt = mean(wt),
          sd_wt = sd(wt),
          n_wt = n()) %>% 
          mutate( prop = n_wt/sum(n_wt))
```

<div class="exercise--instructions__content">
<p>Draw a bar plot with <code>geom_bar()</code>.</p>
<ul>
<li>Using <code>mtcars_by_cyl</code>, plot <code>mean_wt</code> versus <code>cyl</code>.</li>
<li>Add a bar layer, with <code>stat</code> set to <code>"identity"</code> an fill-color <code>"skyblue"</code>.</li>
</ul>
</div>
```{r}
# Using mtcars_cyl, plot mean_wt vs. cyl
ggplot(mtcars_by_cyl, aes(x = cyl, y = mean_wt)) +
  # Add a bar layer with identity stat, filled skyblue
  geom_bar(stat = "identity", fill = "skyblue")
```

<div class="exercise--instructions__content"><p>Draw the same plot with <code>geom_col()</code>.</p>
<ul>
<li>Replace <code>geom_bar()</code> with <code>geom_col()</code>.</li>
<li>Remove the <code>stat</code> argument.</li>
</ul></div>
```{r}
ggplot(mtcars_by_cyl, aes(x = cyl, y = mean_wt)) +
  # Swap geom_bar() for geom_col()
  geom_col(fill = "skyblue")
```

<div class="exercise--instructions__content"><p>Change the bar widths to reflect the proportion of data they contain.</p>
<ul>
<li>Add a <code>width</code> aesthetic to <code>geom_col()</code>, set to <code>prop</code>. (<em>Ignore the warning from ggplot2.</em>)</li>
</ul></div>
```{r}
ggplot(mtcars_by_cyl, aes(x = cyl, y = mean_wt)) +
  # Set the width aesthetic to prop
  geom_col(aes(width = prop), fill = "skyblue")
```

<div class="exercise--instructions__content"><ul>
<li>Add <code>geom_errorbar()</code>.</li>
<li>Set the <code>ymin</code> aesthetic to <code>mean_wt</code> minus <code>sd_wt</code>. Set the <code>ymax</code> aesthetic to the mean weight plus the standard deviation of the weight.</li>
<li>Set the width to <code>0.1</code>.</li>
</ul></div>
```{r}
ggplot(mtcars_by_cyl, aes(x = cyl, y = mean_wt)) +
  geom_col(aes(width = prop), fill = "skyblue") +
  # Add an errorbar layer
  geom_errorbar(
    # ... at mean weight plus or minus 1 std dev
    aes(ymin = mean_wt - sd_wt, ymax = mean_wt + sd_wt),
    # with width 0.1
    width = 0.1
  )
```

<p class="">Awesome Aggregrates! This is a good start, but it's difficult to adjust the spacing between the bars.
</p>

#### Heatmaps use case scenario {.unnumbered}



##### Heat maps {.unnumbered}


<div class>
<p>Since heat maps encode <em>color</em> on a continuous scale, they are difficult to accurately <em>decode</em>, a topic we discussed in the first course. Hence, heat maps are most useful if you have a small number of boxes and/or a clear pattern that allows you to overcome decoding difficulties.</p>
<p>To produce them, map two categorical variables onto the <code>x</code> and <code>y</code> aesthetics, along with a continuous variable onto <code>fill</code>. The <code>geom_tile()</code> layer adds the boxes.</p>
<p>We'll produce the heat map we saw in the video (in the viewer) with the built-in <code>barley</code> dataset. The <code>barley</code> dataset is in the <code>lattice</code> package and has already been loaded for you. Use <code>str()</code> to explore the structure.</p>
</div>


```{r}
# edited/added
library(lattice)
```
<li>Using <code>barley</code>, plot <code>variety</code> versus <code>year</code>, filled by <code>yield</code>.</li>
<li>Add a <code>geom_tile()</code> layer.</li>
```{r}
# Using barley, plot variety vs. year, filled by yield
ggplot(barley, aes(x = year, y = variety, fill = yield)) +
  # Add a tile geom
  geom_tile()
```

<div class="exercise--instructions__content"><ul>
<li>Add a <code>facet_wrap()</code> function with facets as <code>vars(site)</code> and <code>ncol = 1</code>. <em>Strip names will be above the panels, not to the side (as with <code>facet_grid()</code>).</em></li>
<li>Give the heat maps a 2-color palette using <code>scale_fill_gradient()</code>. Set <code>low</code> and <code>high</code> to <code>"white"</code> and <code>"red"</code>, respectively.</li>
</ul></div>
```{r}
# Previously defined
ggplot(barley, aes(x = year, y = variety, fill = yield)) +
  geom_tile() +
  # Facet, wrapping by site, with 1 column
  facet_wrap(facets = vars(site), ncol = 1) +
  # Add a fill scale using an 2-color gradient
  scale_fill_gradient(low = "white", high = "red")
```

```{r}
# edited/added
library(RColorBrewer)
```

<div class="exercise--instructions__content"><p>A color palette of 9 reds, made with <code>brewer.pal()</code>, is provided as <code>red_brewer_palette</code>.</p>
<ul>
<li>Update the fill scale to use an <em>n</em>-color gradient with <code>scale_fill_gradientn()</code> (note the <code>n</code>). Set the scale <code>colors</code> to the red brewer palette.</li>
</ul></div>
```{r}
# A palette of 9 reds
red_brewer_palette <- brewer.pal(9, "Reds")

# Update the plot
ggplot(barley, aes(x = year, y = variety, fill = yield)) +
  geom_tile() +
  facet_wrap(facets = vars(site), ncol = 1) +
  # Update scale to use n-colors from red_brewer_palette
  scale_fill_gradientn(colors = red_brewer_palette)
```

<p class="">Good job! You can continue by using breaks, limits and labels to modify the fill scale and update the theme, but this is a pretty good start.
</p>

##### Useful heat maps {.unnumbered}

<div class=""><p>Heat maps are often a poor data viz solution because they typically don't convey useful information. We saw a nice alternative in the last exercise. But sometimes they <em>are</em> really good. Which of the following scenarios is <em>not</em> one of those times?</p></div>

- [ ] When data has been sorted, e.g. according to a clustering algorithm, and we can see clear trends.
- [ ] When there are few groups with large differences.
- [x] When we have a large data set and we want to impress our colleagues with how complex our work is!
- [ ] When using explanatory plots to communicate a clear message to a non-scientific audience.

<p class="dc-completion-pane__message dc-u-maxw-100pc">Yes. This is typical and it's why many people dislike heatmaps.</p>

##### Heat map alternatives {.unnumbered}


<div class><p>There are several alternatives to heat maps. The best choice really depends on the data and the story you want to tell with this data. If there is a time component, the most obvious choice is a line plot.</p></div>



<li>Using <code>barley</code>, plot <code>yield</code> versus <code>year</code>, colored and grouped by <code>variety</code>.</li>
<li>Add a line layer.</li>
<li>Facet, wrapping by <code>site</code>, with 1 row.</li>
```{r}
# The heat map we want to replace
# Don't remove, it's here to help you!
ggplot(barley, aes(x = year, y = variety, fill = yield)) +
  geom_tile() +
  facet_wrap( ~ site, ncol = 1) +
  scale_fill_gradientn(colors = brewer.pal(9, "Reds"))

# Using barley, plot yield vs. year, colored and grouped by variety
ggplot(barley, aes(x = year, y = yield, color = variety, group = variety)) +
  # Add a line layer
  geom_line() +
  # Facet, wrapping by site, with 1 row
  facet_wrap(~ site, nrow = 1)
```

<div class="exercise--instructions__content"><p>Display only means and ribbons for spread.</p>
<ul>
<li>Map <code>site</code> onto <code>color</code>, <code>group</code> and <code>fill</code>.</li>
<li>Add a <code>stat_summary()</code> layer. set <code>fun.y = mean</code>, and <code>geom = "line"</code>.</li>
<li>In the second <code>stat_summary()</code>, set <code>geom = "ribbon"</code>, <code>color = NA</code> and <code>alpha = 0.1</code>.</li>
</ul></div>
```{r}
# Using barely, plot yield vs. year, colored, grouped, and filled by site
ggplot(barley, aes(x = year, y = yield, color = site, group = site, fill = site)) +
  # Add a line summary stat aggregated by mean
  stat_summary(fun.y = mean, geom = "line") +
  # Add a ribbon summary stat with 10% opacity, no color
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), geom = "ribbon", alpha = 0.1, color = NA)
```

<p class="">Good job! Whenever you see a heat map, ask yourself it it's really necessary. Many people use them because they look fancy and complicated - signs of poor communication skills.
</p>

#### When good data makes bad plots {.unnumbered}



##### Suppression of the origin {.unnumbered}

<p>Suppression of the origin refers to <em>not</em> showing 0 on a continuous scale. When is it inappropriate to suppress the origin?</p>

- [x] When the scale <em>has</em> a natural zero, like height or distance.
- [ ] When the scale <em>doesn't have</em> a natural zero, like temperature (in C or F).
- [ ] When there is a large amount of whitespace between the origin and the actual data.
- [ ] When it does not obscure the shape of the data.

<p class="dc-completion-pane__message dc-u-maxw-100pc">Correct. This would be a good reason to begin at 0, but it's not strictly necessary and not always appropriate.</p>

##### Color blindness {.unnumbered}


<div class>
<p>Red-Green color blindness is surprisingly prevalent, which means that part of your audience will not be able to ready your plot if you are relying on color aesthetics.</p>
<p>Why would it be appropriate to use red and green in a plot?</p>
</div>

- [ ] When red and green are the actual colors in the sample (e.g. fluorescence in biological assays).
- [ ] When red means stop/bad and green means go/good.
- [ ] Because red and green are complimentary colors and look great together.
- [x] When red and green have different intensities (e.g. light red and dark green).

<p class="">If you really want to use red and green, this is a way to make them accessible to color blind people, since they sill still be able to distinguish intensity. It's not as salient as hue, but it still works.
</p>

##### Typical problems {.unnumbered}


<div class>
<p>When you first encounter a data visualization, either from yourself or a colleague, you always want to critically ask if it's obscuring the data in any way.</p>
<p>Let's take a look at the steps we could take to produce and improve the plot in the view.</p>
<p>The data comes from an experiment where the effect of two different types of vitamin C sources, orange juice or ascorbic acid, were tested on the growth of the odontoblasts (cells responsible for tooth growth) in 60 guinea pigs.</p>
<p>The data is stored in the <code>TG</code> data frame, which contains three variables: <code>dose</code>, <code>len</code>, and <code>supp</code>.</p>
</div>
```{r}
# edited/added
library(datasets)
TG = (ToothGrowth)
```

<div class="exercise--instructions__content">
<p>The first plot contains purposely illegible labels. It's a common problem that can occur when resizing plots. There is also too much non-data ink.</p>
<ul>
<li>Change <code>theme_gray(3)</code> to <code>theme_classic()</code>.</li>
</ul>
</div>
```{r}
# Initial plot
growth_by_dose <- ggplot(TG, aes(dose, len, color = supp)) +
  stat_summary(fun.data = mean_sdl,
               fun.args = list(mult = 1),
               position = position_dodge(0.1)) +
  theme_classic()

# View plot
growth_by_dose
```

<div class="exercise--instructions__content"><p>Our previous plot still has a major problem, <code>dose</code> is stored as a <code>factor</code> variable. That's why the spacing is off between the levels.</p>
<ul>
<li>Use <code>as.character()</code> wrapped in <code>as.numeric()</code> to convert the factor variable to real (continuous) numbers.</li>
</ul></div>
```{r}
# Change type
TG$dose <- as.numeric(as.character(TG$dose))

# Plot
growth_by_dose <- ggplot(TG, aes(dose, len, color = supp)) +
  stat_summary(fun.data = mean_sdl,
               fun.args = list(mult = 1),
               position = position_dodge(0.2)) +
  theme_classic()

# View plot
growth_by_dose
```

<div class="exercise--instructions__content"><p>Use the appropriate geometry for the data:</p>
<ul>
<li>In the new <code>stat_summary()</code> function, set <code>fun.y</code> to to calculate the <code>mean</code> and the <code>geom</code> to a <code>"line"</code> to connect the points at their mean values.</li>
</ul></div>
```{r}
# Change type
TG$dose <- as.numeric(as.character(TG$dose))

# Plot
growth_by_dose <- ggplot(TG, aes(dose, len, color = supp)) +
  stat_summary(fun.data = mean_sdl,
               fun.args = list(mult = 1),
               position = position_dodge(0.2)) +
  # Use the right geometry
  stat_summary(fun.y = mean,
               geom = "line",
               position = position_dodge(0.1)) +
  theme_classic()

# View plot
growth_by_dose
```

<div class="exercise--instructions__content"><p>Make sure the labels are informative:</p>
<ul>
<li>Add the units <code>"(mg/day)"</code> and <code>"(mean, standard deviation)"</code> to the x and y labels, respectively.</li>
<li>Use the <code>"Set1"</code> palette.</li>
<li>Set the legend labels to <code>"Orange juice"</code> and <code>"Ascorbic acid"</code>.</li>
</ul></div>
```{r}
# Change type
TG$dose <- as.numeric(as.character(TG$dose))

# Plot
growth_by_dose <- ggplot(TG, aes(dose, len, color = supp)) +
  stat_summary(fun.data = mean_sdl,
               fun.args = list(mult = 1),
               position = position_dodge(0.2)) +
  stat_summary(fun.y = mean,
               geom = "line",
               position = position_dodge(0.1)) +
  theme_classic() +
  # Adjust labels and colors:
  labs(x = "Dose (mg/day)", y = "Odontoblasts length (mean, standard deviation)", color = "Supplement") +
  scale_color_brewer(palette = "Set1", labels = c("Orange juice", "Ascorbic acid")) +
  scale_y_continuous(limits = c(0,35), breaks = seq(0, 35, 5), expand = c(0,0))

# View plot
growth_by_dose
```

<p class="">Great work!
</p>